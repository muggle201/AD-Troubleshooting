$ComputerName = $Env:computername

# Control debug behavior. Default value is False but the value is set from the confiruation file. 
# If we fail to read the file (PSSDIAG.XML) will default to $false
New-Variable SQL:debug      		-Value $false				-Scope 'Global'

# debug flag used by utils_cts (and other scripts)
$debug=$false

if (!$Global:SqlServerRegKey) { #Clear-Variable -scope Global -name SqlServerRegKey} #_# avoid errors when running report a second time in same PS session
	# File policy settings
	New-Variable SQL:FILE_POLICY_SQL_SERVER_ERRORLOGS               -Scope 'Global'
	New-Variable SQL:FILE_POLICY_SQL_SERVER_MINIDUMPS               -Scope 'Global'
	New-Variable SQL:FILE_POLICY_SQL_SERVER_DEFAULT                 -Scope 'Global'
	New-Variable SQL:FILE_POLICY_SQL_SERVER_ALWAYSON_XELOGS         -Scope 'Global'
	New-Variable SQL:FILE_POLICY_SQL_SERVER_FCI_XELOGS              -Scope 'Global'
	New-Variable SQL:FILE_POLICY_SQL_SERVER_SYSTEMHEALTH_XELOGS     -Scope 'Global'
	New-Variable SQL:FILE_POLICY_CONFIGURATION_FILE                 -Scope 'Global'

	# SQL Server registry keys
	#
	New-Variable SqlServerRegKey		                   -Value 'HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server'				                 -Scope 'Global'
	New-Variable SqlServerWow6432RegKey                    -Value 'HKLM:\SOFTWARE\Wow6432Node\Microsoft\Microsoft SQL Server'	                 -Scope 'Global'
	New-Variable SQL:SqlServerInstalledInstancesKey        -Value 'HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL'             -Scope 'Global'
	New-Variable SQL:SqlServerWow6432InstalledInstancesKey -Value 'HKLM:\SOFTWARE\Wow6432Node\Microsoft\Microsoft SQL Server\Instance Names\SQL' -Scope 'Global'

	# Constants used for comparisons
	#
	New-Variable SQL:SERVICE_STATUS_RUNNING      -Value 'RUNNING' 	-Option Constant -Scope 'Global'
	New-Variable SQL:SERVICE_STATUS_STOPPED      -Value 'STOPPED' 	-Option Constant -Scope 'Global'       
	New-Variable SQL:SERVICE_STATUS_PAUSED 	     -Value 'PAUSED' 	-Option Constant -Scope 'Global'
	New-Variable SQL:PROCESS_EXITCODE_SUCCESS 	 -Value 0 	        -Option Constant -Scope 'Global'
	New-Variable SQL:SQL_VERSION_MAJOR_SQL2012	 -Value 11			-Option Constant -Scope 'Global'
	New-Variable SQL:SQL_VERSION_MAJOR_SQL2008	 -Value 10			-Option Constant -Scope 'Global'
	New-Variable SQL:SQL_VERSION_MAJOR_SQL2008R2 -Value 10			-Option Constant -Scope 'Global'
	New-Variable SQL:SQL_VERSION_MAJOR_SQL2005	 -Value 9			-Option Constant -Scope 'Global'

	New-Variable SQL:SqlDefaultInstanceServiceName	 	-Value 'MSSQLSERVER'					-Option Constant -Scope 'Global'
	New-Variable SQL:SqlNamedInstanceSvcNameFirstPart	 -Value 'MSSQL$'						-Option Constant -Scope 'Global'
	New-Variable SQL:SqlBrowserServiceName			     -Value 'SQLBrowser'					-Option Constant -Scope 'Global'

	# SQL Server PowerShell Provider Registry Keys
	#
	New-Variable SQL_2008_PS_REGKEY 	-Value 'HKLM:\SOFTWARE\Microsoft\PowerShell\1\ShellIds\Microsoft.SqlServer.Management.PowerShell.sqlps' 	-Option ReadOnly
	New-Variable SQL_2012_PS_REGKEY	-Value 'HKLM:\SOFTWARE\Microsoft\PowerShell\1\ShellIds\Microsoft.SqlServer.Management.PowerShell.sqlps110' 	-Option ReadOnly

	# SQLCMD utility
	New-Variable SQLCMDEXE	-Value 'SQLCMD.EXE' 	-Option ReadOnly

	# PSSDIAG.XML configuration file
	New-Variable SQL:PSSDIAGXML	-Value 'PSSDIAG.XML' 	-Option ReadOnly    -Scope 'Global'
}

#
# Function : Execute-SqlScript
# ----------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You should call this function to execute an SQL script against SQL Server and collect the results file
#
# Description:
# 			This function will execute a script against SQL Server and collect the output file for upload
#           This function assumes the script will execute once and then exit.  Does not support polling scripts that need to be terminated when collection is complete
#			The script is executed by SQLCMD.EXE
# 
# Arguments:
#			$ConnectToName
#				SQL Server instance to connect to.  Passed for -S SQLCMD parameter.  
#               Format:
#					 NetName\InstanceName.  
#						If SQL Server is clustered the netname should be the SQL Server virtual server name 
#           $ScriptToExecute
#               The TSQL script to execute
#           $OutputFileName
#               Name of output file generated by script execution
#           $SectionDescription
#               Function calls CollectFile to collect the file for upload.  Use this parameter to specify the $SectionDescription in the report
# 
# Owner:
#			DanSha 
#
# Revision History: 
#			1.0 12/2011 DanSha
#				Original version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#
function Execute-SqlScript( [string]$ConnectToName
                           ,[string]$ScriptToExecute
                           ,[string]$OutputFileName
                           ,[string]$SectionDescription
                           ,[string]$FileDescription )
{
	trap 
	{
		'[Execute-SqlScript] : [ERROR] Trapped exception ...' | WriteTo-StdOut
		Report-Error
	}
	
    if ($null -ne $SectionDescription)
    {
        # Verify required parameter specified
    	if ($null -ne $ConnectToName)
        {
            # Verify required parameter specified
            if ($null -ne $ScriptToExecute)
            {
                # To be safe, make sure that the sql script exists in the expected location first ...
            	if ($true -eq (Test-Path (Join-Path -Path $PWD.Path -ChildPath $ScriptToExecute)))
            	{
            		# Build path to input file
            		$InputFilePath = Join-Path -Path $PWD.Path -ChildPath $ScriptToExecute

                    # Now quote the path in case it has imbedded spaces
            		$InputFilePath = "`"$InputFilePath`""
            		
                    # Verify required parameter specified
                    if ($null -ne $OutputFileName)
                    {
                		# Build destination path where we will create the output file
                		$DestinationPath = Join-Path -Path $PWD.Path -ChildPath $OutputFileName
                        
                		# Quote the DestinationPath to guard against imbedded spaces in instance name
                		$DestinationPath = "`"$DestinationPath`""

                		# Quote the ConnectToName to guard against possible imbedded spaces in instance name
                		$ConnectToName = "`"$ConnectToName`""
                		
                		# Build SQLCMD commandline to execute. Redirecting stderr to stdout so that any errors will be written to output file
                		$CommandLineToExecute = "cmd.exe /c {0} -S{1} -E -w20000 -i{2} -o{3}" -f $SQLCMDEXE, $ConnectToName, $InputFilePath , $DestinationPath
                		
                		# Execute the script using SQLCMD
                		if ( $global:SQL:PROCESS_EXITCODE_SUCCESS -ne ($ProcessExitCode = RunCmD -commandToRun $CommandLineToExecute -sectionDescription $SectionDescription  -fileDescription $FileDescription -useSystemDiagnosticsObject))
                		{
                			# Command failed, issue error message for debugging purposes
                			"[Execute-SqlScript] : [ERROR] Failed to execute script: [{0}] RunCMD failed with ProcessExitCode [{1}]. Errors were logged to file: [{2}]" -f (Join-Path -Path $PWD.Path -ChildPath $ScriptToExecute), $ProcessExitCode, $DestinationPath | WriteTo-StdOut	
                			"[Execute-SqlScript] : [ERROR] Failed command was : [{0}]" -f $CommandLineToExecute
                		}
                		
                        # We need to collect the output file for success and failure cases.  For failure cases error messages are logged to the out file 
                	    CollectFiles -FilesToCollect $OutputFileName -SectionDescription $SectionDescription			
                        
                    } # if ($null -ne $OutputFileName)
                    else
                    {
                        "[Execute-SqlScript] : [ERROR] Invalid destiation path : [{0}]" -f $DestinationPath
                        Report-Error
                    }
            	}
            	else
            	{
            		"[Execute-SqlScript] : [ERROR] Script input file: [{0}] could not be found.  Script will not be executed." -f (Join-Path -Path $PWD.Path -ChildPath $ScriptToExecute) | WriteTo-StdOut
                    Report-Error
            	} 
                
            } # if ($null -ne $ScriptToExecute)
            else
            {
                '[Execute-SqlScript] : [ERROR] Required parameter -ScriptToExecute was not specified' | WriteTo-StdOut
            } 
        
        } # if ($null -ne $ConnectToName)
        else
        {
            '[Execute-SqlScript] : [ERROR] Required parameter -ConnectToName was not specified' | WriteTo-StdOut
        }
    } # if ($null -ne $SectionDescription)
    else
    {
        '[Execute-SqlScript] : [ERROR] Required parameter -SectionDescription was not specified' | WriteTo-StdOut
    }
}
# Function : Get-SqlInstanceRootKey
# ---------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - call this function from your trap handler and pass it $error[0]
#
# Description:
#        Retrieves the "root" registry key for a given SQL Server instance
# 
# Arguments:
#		$SqlInstanceName: Instance name of SQL Server instance for which you want to retrieve the root registry key
# 
#
# Owner:
#		DanSha 
#
# Revision History: 
#			1.0 08/2011    DanSha
#				Original version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
 
function Get-SqlInstanceRootKey([string]$SqlInstanceName)
{
    trap 
    {
    	'[Get-SqlInstanceRootKey] : [ERROR] Trapped exception ...' | WriteTo-StdOut
    	Report-Error
    }

    # Check if $SqlInstanceName parameter was specified
    if ($null -ne $SqlInstanceName)
    {
        # Figure out which registry to use ... Is this a Wow6432 instance?
    	#
    	if ($true -eq (Check-IsInstanceWow6432 -InstanceName $SqlInstanceName -RegKeyToCheck $global:SQL:SqlServerWow6432InstalledInstancesKey )) 	{ 
    		$InstancesKey = $global:SQL:SqlServerWow6432InstalledInstancesKey
            $RootSqlKey = $global:SqlServerWow6432RegKey
    	} else {
    		$InstancesKey = $global:SQL:SqlServerInstalledInstancesKey
            $RootSqlKey = $global:SqlServerRegKey
    	}
        
        # The instance name 'DEFAULT' is expected by the SQL PowerShell provider for the default instance
    	# Therefore when we enumerate MSSQLSERVER from the registry we translate it to DEFAULT.
    	# When we go back to the registry to find things for the DEFAULT instance have to translate back to MSSQLSERVER
    	#
    	if ($SqlInstanceName.ToUpper() -eq 'DEFAULT') {$SqlInstanceName = 'MSSQLSERVER'}
        
        if ($null -ne $InstancesKey)
        {
            # Test for valid path
            if ($true -eq (Test-Path -Path $InstancesKey))
            {
                # Make sure that the instance key we're trying to return actually exists under the instance root key
                if ($true -eq (Test-RegistryValueExists -RegKey $InstancesKey -Name $SqlInstanceName))
                {
                    Join-Path -Path $RootSqlKey -ChildPath ((Get-ItemProperty -Path $InstancesKey).$SqlInstanceName)
                    
                    # Check if Join-Path/Get-ItemProperty failed with an error
                    if ($false -eq $?)
                    {
                       '[Get-SqlInstanceRootKey] : [ERROR] Call to Join-Path / Get-ItemProperty failed' | WriteTo-StdOut
					   Report-Error
                    }
                }
                
            }
            else
            {
                '[Get-SqlInstanceRootKey] : [WARN] Registry key: [{0}] for instance: [{1}] was not found. This key is used to locate the instance root key for a SQL Server installation' -f $InstancesKey, $SqlInstanceName | WriteTo-StdOut  
				'[Get-SqlInstanceRootKey] : [WARN] This may be expected if [{0}] is a SQL Server 2000 default instance' -f $SqlInstanceName | WriteTo-StdOut  
            }
        }
        else
        {
            '[Get-SqlInstanceRootKey] : [ERROR] Join-Path returned $null' | WriteTo-StdOut  
            Report-Error 
        }

    } # if ($null -ne $SqlInstanceName)
    else
    {
        '[Get-SqlInstanceRootKey] : [ERROR] Required parameter: $SqlInstance was not specified' | WriteTo-StdOut  
    
    }
   
}

#
# Function :  Get-LcidForSqlServer
# --------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Revision History: 
#			1.0 01/22/2012 DanSha
#				Original version
#
# Note:
#     Stubbing this function out for now until we can figure out how to correctly do this (DanSha : 01/22/2012)
#
# Visibility:
#			Public - Call this function from your PowerShell scripts to retrieve the LCID for the SQL Server Service
#
# Description:
# 			This function is used to retrieve the LCID for a given SQL Server service
# 
# Arguments:
#			$InstanceName
#			Retrieve the LCID for the instance passed in $InstanceName
# 
# Owner:
#			DanSha 
#

function Get-LcidForSqlServer ([string]$SqlInstanceName)
{
    # For now, return the default value of 1033
    
    return [string]'1033'
}

#
# Function :  Get-SqlServerLogPath
# ---------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Revision History: 
#			1.0 08/??/2011 DanSha
#				Original version
#			1.1 11/23/2011 DanSha
#				Had to change function to use strings rather than paths so that the function won't 
#				throw an error on Windows clusters when the drive where the SQL errorlogs are stored is offline
#
# Visibility:
#			Public - Call this function from your PowerShell scripts to retrieve the default SQL Server log path.  
#
# Description:
# 			This function is used to find the default log path for a given SQL Server instance
# 
# Arguments:
#			$InstanceName
#			Function will find the path to the errorlogs and other logs stored in the \LOG folder for the instance passed 
# 
# Returns:
#			Path to the SQL Server Errorlog or $null if an invalid instance is passed. 
#			Caller should test for $null to be sure the path was found
# Owner:
#			DanSha 
#
# Revision History: 
#			1.0 08/2011		DanSha
#				Original version
#			1.1 01/18/2012	DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#			1.2 02/03/2012	DanSha
#				Added ErrorAction STOP to Get-Item and Get-ItemProperty so that the trap handler will fire
#				as opposed to falling through statements following an error
#				Also added a trap handler to catch the exception that would be raised resulting from the above
#				change 

function Get-SqlServerLogPath( [string]$SqlInstance )
{
    trap 
    {
    	'[Get-SqlServerLogPath] : [ERROR] Trapped exception ...' | WriteTo-StdOut        
     	Report-Error
    }
    
    # Check if $SqlInstance required parameter value was passed
    if ($null -ne $SqlInstance)
    {
        # Get root key for this instance
    	$SqlInstanceRootKey = Get-SqlInstanceRootKey -SqlInstanceName $SqlInstance
        
        if ($null -ne $SqlInstanceRootKey)
        {
        	# Get path to parameters for this instance
            $SqlServerParametersPath = Join-Path -Path $SqlInstanceRootKey -ChildPath '\MSSQLServer\Parameters'
        	
        	if ($true -eq (Test-Path -Path $SqlServerParametersPath))
        	{				
        		# Get the MSSQLServer\Parameters Key
                # Specify an ErrorAction of STOP. If we don't, the next command, Get-ItemProperty will fail due to a $null parameter 
        		#
        		$sqlParametersKey = Get-Item -Path $SqlServerParametersPath 
        		if ($null -ne $sqlParametersKey)
        		{
        			$values = Get-ItemProperty -Path $sqlParametersKey.PSPath 
        			
        			if ($null -ne $values)
        			{
        				foreach ($value in $sqlParametersKey.Property) 
        				{					
        					# We want the -e parameter that tells the server where to create the errorlog
        					#
        					if ($values.$value -match '^-e(.+)') 
        					{
        						# $matches is set with matches from the above -match/regex search
        						$SqlServerLogPath = [System.IO.Path]::GetDirectoryName($matches[1]) 
        	
        						# GetDirectoryName failed.  Before we retun log the error that caused the failure
        						if ($false -eq $?)
        						{
        							"[Get-SqlServerLogPath] : [ERROR] Error encountered retrieving SQL Server log path from: [{0}]" -f $values.$value | WriteTo-StdOut
        							Report-Error
        						}

    							break
        					}
        				}
        			} #if ($null -ne $values)
        			else
        			{
        				"[Get-SqlServerLogPath] : [ERROR] Get-ItemProperty of `$sqlParametersKey.PSPath: [{0}] returned `$null" -f $sqlParametersKey.PSPath | WriteTo-StdOut
        				Report-Error
        			}
        		} # if ($null -ne $sqlParametersKey)
        		else
        		{
        			"[Get-SqlServerLogPath] : [ERROR] Error encountered retrieving SQL Server parameters using path: [{0}]" -f $SqlServerParametersPath | WriteTo-StdOut
        			Report-Error
        		}
    			
        	} #if ($true -eq (Test-Path -Path $SqlServerParametersPath))
            else
            {
                "[Get-SqlServerLogPath] : [ERROR] Invalid registry key [{0}]" -f $SqlServerParametersPath | WriteTo-StdOut
        		Report-Error  
            }
    		
       } #  if ($null -ne $SqlInstanceRootKey)
       else
       {
       		'[Get-SqlServerLogPath] : [ERROR] Get-SqlInstanceRootKey returned $null' | WriteTo-StdOut
       }
       
   } #if ($null -ne $SqlInstance)
   else
   {
    '[Get-SqlServerLogPath] : [ERROR] Required parameter: SqlInstance not specified' | WriteTo-StdOut
   }
   
   return $SqlServerLogPath
}

#
# Function :  Check-IsSqlDiskResourceOnline
# -----------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Revision History: 
#			1.0 11/23/2011 DanSha
#				Original Version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#
# Purpose:
#			We have several collectors that retrieve file locations from the registry.  On a Windows failover cluster
#			the drive referenced by a given path could be offline from the node the collector is executing against
#			When a Test-Path fails for a path retrieved from the registry this function is called to log additional
#			information about the cause of the failure if possible
#
# Visibility:
#			Public - You can call this function from your PowerShell scripts 
#
# Description:
# 			This function is used to test whether a drive is online to a machine
# 
# Arguments:
#			$InstanceName
#			Needed to check whether the drive is likely a cluster resource. If SQL is clustered the drive
#			may be Sql Disk Resource.
#			$PathToTest
#			String representation of the path that failed validation (usually with Test-Path)
# 
# Owner:
#			DanSha 
#
function Check-IsSqlDiskResourceOnline( [string]$InstanceName
                                      , [string]$PathToTest )
{
    trap 
    {
    	'[Check-IsSqlDiskResourceOffline] : [ERROR] Trapped exception ...' | WriteTo-StdOut
    	Report-Error
    }
    
	[System.Boolean]$DiskOnline=$false
    if ($null -ne $InstanceName)
	{
		if ($null -ne $PathToTest)
	    {
		    $Drive = ($PathToTest.Split('\'))[0]
	        if ($null -ne $Drive)
	        {
	            # Is the drive letter valid? If so, drive is online
				if (Test-Path -Path $Drive)
	            {
	                # Disk online
	                $DiskOnline = $true
	            }
	            else  
	            {
					$IsClustered = Get-IsSqlInstanceClustered $InstanceName
					# Only attempt to verify that this is a disk cluster resource if the SQL instance is clustered
					if ($true -eq $IsClustered)
					{
						# If FindSqlDiskResource returns false the disk is an offline cluster resource or an invalid drive letter
		            	#
		           		if (($DiskOnline = FindSQLDiskResource($Drive)) -eq $false)
		            	{
							# Disk is offline ...
		           		    [System.Boolean]$DiskOnline=$false
							"[Check-IsSqlDiskResourceOnline] : [ERROR] Invalid Path [{0}]. The cluster disk resource: [{1}] for instance: [{2}] is offline from this node at this time" -f $PathToTest, $Drive, $InstanceName | WriteTo-StdOut
		                }
		         	} # if ($true -eq $IsClustered)
					else
					{
						"[Check-IsSqlDiskResourceOnline] : [ERROR] Invalid Path [{0}]. Drive letter: [{1}] is invalid. Instance name is: [{2}] " -f $PathToTest, $Drive, $InstanceName | WriteTo-StdOut
					}
	            } # else
			}
	        else
	        {
	            "[Check-IsSqlDiskResourceOnline] : [ERROR] Unable to extract drive letter from path [{0}]." -f $PathToTest | WriteTo-StdOut
	        }        
	    } # if ($null -ne $InstanceName) -or ($null -ne $PathToTest)
		else
		{
			'[Check-IsSqlDiskResourceOnline] : [ERROR] Required parameter: -PathToTest was not specified.' | WriteTo-StdOut
		}
    } # if (($null -ne $InstanceName)
	else
    {
  	  	'[Check-IsSqlDiskResourceOnline] : [ERROR] Required parameter: -InstanceName was not specified.' | WriteTo-StdOut	
	}
    return $DiskOnline
}

# Function : Show-ErrorDetails
# ---------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - call this function from your trap handler and pass it $error[0]
#
# Description:
#        Formats and displays information present in $error. Writes output to stdout.log
#		 Function is pretty much lifted from Windows Powershell in Action by Bruce Payette
# 
# Arguments:
#		$ErrorRecord: Pass $error[0] to display information about the most recent error/exception encountered
#
# Dependancy :
#		RS SDP Manifest and SQL Manifest consumes this function
# 
# Example:
#       Show-ErrorDetails $error[0] 
#
# Owner:
#		DanSha 
#
# 
function Show-ErrorDetails 
{
	param( $ErrorRecord = $Error[0] )

	$ErrorMessage = $ErrorRecord.Exception.Message
	("[Show-ErrorDetails] : Error message: {0}" -f $ErrorMessage) | WriteTo-StdOut
    $ErrorRecord.InvocationInfo | Format-List * -Force | out-string | WriteTo-Stdout
	
	$Exception = $ErrorRecord.Exception
	
	for ($depth = 0; $null -ne $Exception; $depth++)
	{
		"$depth" * 80 | WriteTo-StdOut
		$Exception | Format-List -Force * | Out-String | WriteTo-StdOut 
		$Exception = $Exception.InnerException
	}
}

# Function : Report-Error
# ------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - call this function from your trap handler and pass it the entire $error object
#
# Description:
#        It's possible that your trap handler could get called by an exception that was caused by a prior error
#		 If we only dump error[0] we will only report the symptom of a prior error and not the cause
#		 To be safe, any time we report an exception we need to dump the entire $error object.  Since we call $error.Clear
#		 at entry to any function that installs a trap handler this should be a safe practice that only reports errors that we
#		 are interested in.  With that being said, there are some functions like Check-IsSqlInstanceWow6432 where we purposely specify
#		 an -ErrorAction of SilentlyContinue. If an exception is raised after one of these functions are called we must be cognizant of 
#        this fact and ignore the invalid path error.  Hopefully this will not cause confusion. 
# 
# Arguments:
#		$TrappedErrors: Pass the entire $error object
#
# Dependancy :
#		RS SDP Manifest and SQL Manifest consumes this function
# 
# Example:
#       Report-Error -TrappedErrors $error
#
# Owner:
#		DanSha 
#
# 
function Report-Error ([object] $TrappedErrors = $Error)
{
   if ($null -ne $TrappedErrors)
   {
        if (0 -lt $TrappedErrors.Count)
        {
            '[Report-Error] : [INFO] Preparing to report on error condition(s) ...' | WriteTo-StdOut
            "[Report-Error] : [INFO] Count of errors is: {0}" -f $TrappedErrors.Count | WriteTo-StdOut
            
            foreach ($trappedError in $TrappedErrors)
            {            
                Show-ErrorDetails $trappedError
            }

			# Clear the error object since we just finished dumping them all
			$Error.Clear()
        }
    }

}

#
# Function : Load-SqlSnapins
# --------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Private/Internal - Do not call this function from your PowerShell scripts.  
#
# Description:
# 			This function should be used to pre-load various SQL Server assemblies and the SQL Server PS Snap-ins
#			This function is documented in SQL Server 2008 BOL
#			If you "dot source" utils_DSD in your TS_Main the SQL Server PowerShell snapins are loaded automatically by the Initialize_DsdEnvironment function
# 			NOTE: Assemblies do not have to be pre-loaded as below.  However, if the functionality exposed by the assembly is utilized 
#				  before the provider is loaded the statement will fail
# 
# Arguments:
#			None
# 
# Owner:
#			DanSha 
#
# Revision History:
#
#           1.0 08/2011    DanSha
#               Original Version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#
function Load-SqlSnapins () 
{
	#
	# Add the SQL Server PowerShell snapins.
	#

    # Right now, we are not using the SQL PS Snapins so we don't care if they fail to load
    # If we take a future dependency, the ErrorActionPreference should be set to STOP
	$ErrorActionPreference = 'Stop'
	
	[bool]$IsSql2008Provider = $false
	[bool]$IsSql2012Provider = $false
	
	# Check if the SQL Server PS Snapins are installed on this machine ...
	if (Check-SqlSnapinsAreInstalled)
	{
		# The SQL 2008/2008 R2 and Denali PS Providers are backwards compatible with prior versions of SQL Server
		# Load the most current version that is installed on the machine
		#
		if ( (Test-Path -Path $SQL_2012_PS_REGKEY -ErrorAction SilentlyContinue) -eq $true)	
		{
			$IsSql2012Provider = $true
		} 
		elseif ( (Test-Path -Path $SQL_2008_PS_REGKEY -ErrorAction SilentlyContinue) -eq $true) 
		{
			$IsSql2008Provider = $true
			
			$item = Get-ItemProperty $SQL_2008_PS_REGKEY
			# Location of SQL PS Provider and Snap-ins
			$SqlPsPath = [System.IO.Path]::GetDirectoryName($item.Path)
		} 
	} 
	else 
	{
	 	'[Load-SqlSnapins] : [INFO] No SQL Server PowerShell snap-ins are installed on this machine' | WriteTo-StdOut
	}
	
	#
	# Set mandatory variables for the SQL Server rovider
	#
	Set-Variable -scope Global -name SqlServerMaximumChildItems -Value 0
	Set-Variable -scope Global -name SqlServerConnectionTimeout -Value 30
	Set-Variable -scope Global -name SqlServerIncludeSystemObjects -Value $false
	Set-Variable -scope Global -name SqlServerMaximumTabCompletion -Value 1000
    
    #
	# Preload the assemblies. Note that most assemblies will be loaded when the provider
	# is used. if you work only within the provider this may not be needed. It will reduce
	# the shell's footprint if you leave these out.
	#

	$assemblylist = 
	'Microsoft.SqlServer.Management.Common',
	'Microsoft.SqlServer.Smo',
	'Microsoft.SqlServer.Dmf',
	'Microsoft.SqlServer.Instapi',
	'Microsoft.SqlServer.SqlWmiManagement',
	'Microsoft.SqlServer.ConnectionInfo',
	'Microsoft.SqlServer.SmoExtended',
	'Microsoft.SqlServer.SqlTDiagM',
	'Microsoft.SqlServer.SString',
	'Microsoft.SqlServer.Management.RegisteredServers',
	'Microsoft.SqlServer.Management.Sdk.Sfc',
	'Microsoft.SqlServer.SqlEnum',
	'Microsoft.SqlServer.RegSvrEnum',
	'Microsoft.SqlServer.WmiEnum',
	'Microsoft.SqlServer.ServiceBrokerEnum',
	'Microsoft.SqlServer.ConnectionInfoExtended',
	'Microsoft.SqlServer.Management.Collector',
	'Microsoft.SqlServer.Management.CollectorEnum',
	'Microsoft.SqlServer.Management.Dac',
	'Microsoft.SqlServer.Management.DacEnum',
	'Microsoft.SqlServer.Management.Utility'

	foreach ($asm in $assemblylist)
	{
		$asm = [Reflection.Assembly]::LoadWithPartialName($asm)
	}
	
	if ($IsSql2008Provider)
	{
        # Load the snapins, type data, format data
	    #
	    Push-Location
	    Set-Location $SqlPsPath
        
		# Load SQL 2008 PS Provider
		Add-PSSnapin SqlServerCmdletSnapin100
		Add-PSSnapin SqlServerProviderSnapin100
		Update-TypeData -PrependPath SQLProvider.Types.ps1xml 
		update-FormatData -prependpath SQLProvider.Format.ps1xml 
        
        Pop-Location
	}
	elseif ($IsSqlDenaliProvider)
	{
		# SQL Denali PS Module changes default drive to SQLSERVER:\ after it loads which causes the package execution to fail
		# So, need to use push and pop to restore home directory after loading provider
		Push-Location

        # The SQL Server 2012 PowerShell provider requires PowerShell 2.0.  
        # PowerShell 2.0 is an installation prerequisite for SQL Server 2012
        # As such, we do not need to check the version of PowerShell before attempting to load the SQL Server 2012 provider
        
		# Load Denali PS Module
		Import-Module -Name 'SQLPS' -DisableNameChecking 

		Pop-Location
	}	
}

#
# Function : Get-Count
# ---------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - Call this function from your PS script
#
# Description:
# 			Call this function to count the number of objects produced by a powershell pipeline
# 			NOTE:	This function will not properly count the items stored in collections like arrays, hashtables, dictionaries, etc.
#					Wouldn't be hard to add this functionality but it's not there yet
# 
# Arguments:
#			To be used within a pipeline. Receives input from pipeline
#
# Dependancy :
#		RS SDP Manifest and SQL Manifest consumes this function
# 
# Owner:
#			DanSha 
#
function Get-Count()
{
    begin
	{
        $n = 0
    }
    process 
	{
		if ($null -ne $input) 
		{
        	$n += 1
		}
    }
    end 
	{
        return $n
    }
}

#
# Function : Check-SqlSnapinsAreLoaded 
# ------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - Can call this function from your PS script but you shouldn't need to. Read on ...
#
# Description:
# 			Call this function before attempting to load the SQL Server PowerShell snapins
#			If this function returns true then the SQL Server Snapins are already loaded 
#			If you dot source" utils_DSD it loads the SQL Server Powershell snapins into your powershell session automatically and there should be no reason to call this function
# 
# Arguments:
#			None
#
# Returns:
#			$true if the SQL Server Powershell snapins are already loaded
#			$false if the SQL Server PowerShell snapins are not already loaded
# 
# Owner:
#			DanSha 
#
# Revision History:
#
#           1.0 08/2011    DanSha
#               Original Version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#
function Check-SqlSnapinsAreLoaded ()
{
    return ( (Get-PSSnapin | Where-Object {$_.Name -like 'SqlServer*'} | Get-Count) -gt 0)
}

#
# Function : Check-SqlSnapinsAreInstalled 
# ---------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Private/Internal - Do not call this function
#
# Description:
# 			Call this function to determine whether the SQL Server Snapins are installed on a given machine
#			If you "dot source" utils_DSD it loads the SQL Server Powershell snapins into your powershell session automatically and there should be no reason to call this function
# 
# Arguments:
#			None
#
# Returns:
#			$true if the SQL Server Powershell snapins are installed on this machine
#			$false if the SQL Server PowerShell snapins are not installed on this machine
# 
# Owner:
#			DanSha 
#
function Check-SqlSnapinsAreInstalled ()
{
	return ( 	(Test-Path -Path $SQL_2008_PS_REGKEY -ErrorAction SilentlyContinue) `
			-or (Test-Path -Path $SQL_2012_PS_REGKEY -ErrorAction SilentlyContinue) )
}

#
# Function : Check-SqlServerIsInstalled
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public/Helper 
#
# Description:
# 			Call this function to determine whether the SQL Server is installed. Checks for regular or WOW6432 installations.
# 
# Arguments:
#			None
#
# Returns:
#			$true if at least one SQL Server installation exists on the target machine.
#			$false if no SQL Server installations exist on the target macine
# 
# Owner:
#			DanSha 
#

function Check-SqlServerIsInstalled
{
	[int]$count=0

	$count=((Enumerate-Instances -KeyToEnumerate $global:SQL:SqlServerInstalledInstancesKey  -SilentMode | Get-Count) + `
		    (Enumerate-Instances -KeyToEnumerate $global:SQL:SqlServerWow6432InstalledInstancesKey -SilentMode | Get-Count))

	#Clear any errors generated by above commands.  Otherwise, this could be reported with another unexpected error and cause confusion
	$Error.Clear()

	return ($count -gt 0)
}
	
#
# Function : Test-RegistryValueExists 
# -----------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You can call this function from your PS script
#
# Description:
# 			Checks whether the registry value passed exists under the registry key passed
# 
# Arguments:
#			$RegKey is the key to check for the existend of the passed registry value, $name
#			$Name is the registry value to check under the registry key that was passed to the function in $RegKey
#
# Dependancy :
#		RS SDP Manifest and SQL Manifest consumes this function
#
# Returns:
#			$true if the registry value passed exists under the registry key that was passed
#			$false if the registry value passed does not exist under the registry key that was passed
# 
# Owner:
#			DanSha 
#
function Test-RegistryValueExists( [string]$RegKey
                                 , [string]$Name ) 
{  
	if ($null -ne $RegKey)
    {
        
        if ($null -ne $Name)
        {
            
            if ($true -eq (Test-Path -Path $RegKey))
            {
                Get-ItemProperty -Path $RegKey -Name $Name -ErrorAction SilentlyContinue | Out-Null 
                $ReturnValue=$?
                
                if ($false -eq $ReturnValue)
                {
                     "[Test-RegistryValueExists] : [INFO] Registry value : [{0}] not found under key: [{1}]" -f $Name, $RegKey  | WriteTo-StdOut         
                }
            }
            else
            {
                # We get here if the path passed to Test-RegistryValueExists is invalid
                # We cannot do away with this else block and just return $? because the if command succeeds either way (whether path is valid or invalid)
                $ReturnValue=$false
            }
            
        }
        else
        {
             '[Test-RegistryValueExists] : [ERROR] Required parameter -Name was not specified' | WriteTo-StdOut
        }
    
    }
    else
    {
        '[Test-RegistryValueExists] : [ERROR] Required parameter -RegKey was not specified' | WriteTo-StdOut
    }
    
	#Returns true if above command succeeds (i.e. property exists, else false)
	return($ReturnValue)
}

function Test-RegistryValueIsNull([string]$RegistryKey, [string]$RegistryValueName)
{
    # Parameter validation
    if ($null -ne $RegistryKey)
    {
        # Parameter validation
        if ($null -ne $RegistryValueName)
        {
            # Test for valid path
            if ($true -eq (Test-Path -Path $RegistryKey))
            {
                # See if registry value exists under the key passed before accessing it
                if ($true -eq (Test-RegistryValueExists -RegKey $RegistryKey -Name $RegistryValueName))
                {
                    $RegistryValue=(Get-ItemProperty -Path $RegistryKey).$RegistryValueName
                }
                else
                {
                    '[Test-RegistryValueIsNull] : [ERROR] Registry Value: [{0}] does not exist under key: [{1}]' -f $RegistryValueName, $RegistryKey | WriteTo-StdOut
                }
            }
            else
            {
                '[Test-RegistryValueIsNull] : [ERROR] Invalid registry path: [{0}]' -f $RegistryKey | WriteTo-StdOut
            }
        }
        else
        {
             '[Test-RegistryValueIsNull] : [ERROR] Required parameter -RegistryValueName was not supplied' | WriteTo-StdOut
        }
    } # if ($null -ne $RegistryKey)
    else
    {
        '[Test-RegistryValueIsNull] : [ERROR] Required parameter -RegistryKey was not supplied' | WriteTo-StdOut
    }
    
    return ( (($null-eq $RegistryValue) -or (0 -eq $RegistryValue.Length)) )
}


# Function : Check-IsInstanceWow6432 
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You can call this function from your PS script
#
# Description:
# 			Call this function to determine whether the SQL Server instance passed is a Wow6432 instance
# 
# Arguments:
#			$instance is the instance to check. Do not pass the instance name prepended with the machine name i.e. NetName\InstanceName
#			For the default instance pass "MSSQLSERVER" (not "DEFAULT")
#           $RegKeyToCheck - Registry key to check if any instances are insstalled
#
# Returns:
#			$true if the instance passed is a Wow6432 instance
#			$false if the instance passed is not a Wow6432 instance
# 
# Owner:
#			DanSha 
#
function Check-IsInstanceWow6432([string] $InstanceName, [string]$RegKeyToCheck=$global:SQL:SqlServerWow6432InstalledInstancesKey)
{
  #return ( ((Get-ItemProperty -ErrorAction SilentlyContinue -Path ($SqlServerWow6432RegKey)).InstalledInstances  | Where-Object {$_ -eq $InstanceName} | Get-Count) -gt 0)
  return  ( (Enumerate-Instances -KeyToEnumerate $RegKeyToCheck -SilentMode  | Where-Object {$_ -eq $InstanceName} | Get-Count) -gt 0)
}


# Function : Get-InstalledServices
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You can call this function from your PS script
#
# Description:
# 			Call this function if you need to retrieve all services installed on the machine and need the return type as PSObject array.
#			This function returns the following service Properties:
#				1.Name
#				2. DisplayName
#				3. State
#				4. StartupType
#				5. LogOnAs
#				6. PathToExecutable
#				7. Description
#				8. ProcessId
#				9. DesktopInteract
#				10. SystemName
#			
# Arguments:
#			ComputerName from where to get services Info - for local machine, pass $env:ComputerName
#
# Returns:
#			PSObject array - each member in the array contains the above properties
# 
# Owner:
#			muddin
#
# Revision History:
#
#           1.0 06/2012    muddin
#               Original Version
#			1.1 09/2012
#				Rewrote the function to get services info from WMI
#
Function Get-InstalledServices( [string] $ComputerName)
{
	$Error.Clear()           
    trap 
    {
    	'[Get-InstalledServices] : Trapped error ...' | WriteTo-StdOut
    	Report-Error
    }

	$allServicesPSOArray = @()
	
	if ( $true -eq [System.String]::IsNullOrEmpty($ComputerName) )
	{
		'[Get-InstalledServices] : [ERROR] Required parameter: -ComputerName: [{0}] was not specified or an invalid parameter was passed.' -f $ComputerName | WriteTo-StdOut
	}
	else
	{
		$allServices = Get-CimInstance -Class Win32_Service -ComputerName $ComputerName -ErrorAction SilentlyContinue
		if ( $null -ne $allServices )
		{
	foreach ($service in $allServices)
	{
				$svcProperties = New-Object PSObject
				Add-Member -InputObject $svcProperties -MemberType NoteProperty -Name "ServiceName" 	-Value $service.Name
				Add-Member -InputObject $svcProperties -MemberType NoteProperty -Name "DisplayName" 	-Value $service.DisplayName
				Add-Member -InputObject $svcProperties -MemberType NoteProperty -Name "Description" 	-Value $service.Description
				Add-Member -InputObject $svcProperties -MemberType NoteProperty -Name "State" 			-Value $service.State
				Add-Member -InputObject $svcProperties -MemberType NoteProperty -Name "LogOnAs" 		-Value $service.StartName
				Add-Member -InputObject $svcProperties -MemberType NoteProperty -Name "StartupType"       -Value $service.StartMode
				Add-Member -InputObject $svcProperties -MemberType NoteProperty -Name "PathToExecutable" -Value $service.PathName
				Add-Member -InputObject $svcProperties -MemberType NoteProperty -Name "ProcessId" 	-Value $service.ProcessId
				Add-Member -InputObject $svcProperties -MemberType NoteProperty -Name "DesktopInteract" -Value $service.DesktopInteract
				Add-Member -InputObject $svcProperties -MemberType NoteProperty -Name "ComputerName" -Value $service.SystemName
			
				$allServicesPSOArray += $svcProperties
		}
	}
		else
		{
			'[Get-InstalledServices] : [ERROR] Failed to retrieve Services info on the computer: [{0}]' -f $ComputerName | WriteTo-StdOut
		}
	}

	return $allServicesPSOArray

}

# Function : Export-AllServicesToXml
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You can call this function from your PS script
#
# Description:
# 			Call this function if you need an XML Output of all services installed on the machine.
#			This function uses Get-InstalledServices() and lists only certain service properties currently and not all properties- 
#			Extend Get-InstalledServices if more properties are intended in the XML output.
#			
# 
# Arguments:
#			[string]$ExportPath - Path where the XML output is saved.
#
# Returns:
#			void
# 
# Owner:
#			muddin
#
# Revision History:
#
#           1.0 06/2012    muddin
#               Original Version
#			1.1 09/2012
#				modified call to Get-InstalledServices to add parameter
#			1.2 12/2012
#				modified XML Output implementation
#
Function Export-AllServicesToXml([string]$ExportPath)
{
	$Error.Clear()           
    trap 
    {
    	'[Export-AllServicesToXml] : Trapped error ...' | WriteTo-StdOut
    	Report-Error
    }
	
	if ( $true -eq [System.String]::IsNullOrEmpty($ExportPath) )
	{
		'[Export-AllServicesToXml] : [ERROR] Required parameter: -ExportPath: [{0}] was not specified or an invalid parameter was passed.' -f $ExportPath | WriteTo-StdOut
	}
	else
	{

		$installedServices = Get-InstalledServices -ComputerName $env:COMPUTERNAME
	
		# commentting out the line below (use of Export-CLIXML), as output from Export-CLIXML is not user friendly and also not suitable for further processing in UDE
		# Export-CLIXML was not designed for UI
		#	if ($installedServices)
		#     {
		#	 	#export to an XML file on the path specified
		#     	$installedServices | Export-CLIXML -Path $ExportPath
		#     }
	 
		# XMLDocument 
		[xml]$xmlInstalledServices = [xml]"<?xml version=""1.0"" encoding=""utf-8""?><Services></Services>"
	
		if ($null -ne $installedServices)
		{
			# iterate through the array of PSObjects
			foreach ($service in $installedServices)
			{
			
				$serviceNode = $xmlInstalledServices.CreateElement("Service")
 				[Void]$xmlInstalledServices["Services"].AppendChild($serviceNode)
			
				$name = $xmlInstalledServices.CreateElement("Name")
				$name.psbase.InnerText = $service.ServiceName
 				[Void]$serviceNode.AppendChild($name)
			
				$displayName = $xmlInstalledServices.CreateElement("DisplayName")
				$displayName.psbase.InnerText = $service.DisplayName
 				[Void]$serviceNode.AppendChild($displayName)
			
				$description = $xmlInstalledServices.CreateElement("Description")
				$description.psbase.InnerText = $service.Description
 				[Void]$serviceNode.AppendChild($description)
			
				$state = $xmlInstalledServices.CreateElement("State")
				$state.psbase.InnerText = $service.State
 				[Void]$serviceNode.AppendChild($state)
			
				$logOnAs = $xmlInstalledServices.CreateElement("LogOnAs")
				$logOnAs.psbase.InnerText = $service.LogOnAs
 				[Void]$serviceNode.AppendChild($logOnAs)
			
				$startupType = $xmlInstalledServices.CreateElement("StartupType")
				$startupType.psbase.InnerText = $service.StartupType
 				[Void]$serviceNode.AppendChild($startupType)
			
				$pathToExecutable = $xmlInstalledServices.CreateElement("PathToExecutable")
				$pathToExecutable.psbase.InnerText = $service.PathToExecutable
 				[Void]$serviceNode.AppendChild($pathToExecutable)
			
				$processId = $xmlInstalledServices.CreateElement("ProcessId")
				$processId.psbase.InnerText = $service.ProcessId
 				[Void]$serviceNode.AppendChild($processId)
			
				$desktopInteract = $xmlInstalledServices.CreateElement("DesktopInteract")
				$desktopInteract.psbase.InnerText = $service.DesktopInteract
 				[Void]$serviceNode.AppendChild($desktopInteract)
			
				$comptName = $xmlInstalledServices.CreateElement("ComputerName")
				$comptName.psbase.InnerText = $service.ComputerName
 				[Void]$serviceNode.AppendChild($comptName)
			
			}
		
		}
	
		if ( $null -ne $xmlInstalledServices)
		{
			$xmlInstalledServices.Save($ExportPath)
		}
	}
}



# Function : Get-SqlServiceName 
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You can call this function from your PS script
#
# Description:
# 			Call this function to get the service name for a Sql instance
# 
# Arguments:
#			$SqlInstanceName is the instance to check. Do not pass the instance name prepended with the machine name i.e. NetName\InstanceName
#			For the default instance pass "MSSQLSERVER" (not "DEFAULT")
#
# Returns:
#			Sql Service Name (same as retruned from get-service or Get-CimInstance win32_service)
# 
# Owner:
#			muddin
#
# Revision History:
#
#           1.0 08/2012		muddin
#               Original Version 
#
function Get-SqlServiceName([string]$SqlInstanceName)
{
	trap
    {
        '[Get-SqlServiceName] : [ERROR] Trapped exception ...' | WriteTo-StdOut
        Report-Error    
    }
	
	[string]$sqlServiceName = $null
	
	if ( $false -eq [System.String]::IsNullOrEmpty($SqlInstanceName) )
	{
		if ( ('DEFAULT' -eq $SqlInstanceName.ToUpper() ) -or ('MSSQLSERVER' -eq $SqlInstanceName.ToUpper() ) ) 
		{
    		$sqlServiceName = $global:SQL:SqlDefaultInstanceServiceName 
    	} 
		else 
		{
    		$sqlServiceName = ($global:SQL:SqlNamedInstanceSvcNameFirstPart + $SqlInstanceName )
    	}
        
   }
	else
	{
		'[Get-SqlServiceName] : [ERROR] Required parameter: -SqlInstanceName: [{0}] was not specified' -f $SqlInstanceName | WriteTo-StdOut
	}
	return $sqlServiceName
	
}

# Function : Get-SqlServiceStartupAccount
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You can call this function from your PS script
#
# Description:
# 			Call this function to get the service Startup Account name for a Sql instance
# 
# Arguments:
#			$SqlInstanceName is the instance to check. Do not pass the instance name prepended with the machine name i.e. NetName\InstanceName
#			For the default instance pass "MSSQLSERVER" (not "DEFAULT")
#
# Returns:
#			Sql Service Startup Account Name 
# 
# Owner:
#			muddin
#
# Revision History:
#
#           1.0 08/2012		muddin
#               Original Version 
#
function Get-SqlServiceStartupAccount([string]$SqlInstanceName)
{
	trap
    {
        '[Get-SqlServiceStartupAccount] : [ERROR] Trapped exception ...' | WriteTo-StdOut
        Report-Error    
    }
	
	[string]$sqlServiceStartupAcct = $null
	
	if ( $false -eq [System.String]::IsNullOrEmpty($SqlInstanceName) )
	{
		# Get Windows Service Name based on instance name
		[string]$sqlServiceName = Get-SqlServiceName -SqlInstanceName $SqlInstanceName
		
		if ( $false -eq [System.String]::IsNullOrEmpty($sqlServiceName) )
		{
			$sqlServiceStartupAcct = Get-ServiceStartupAccount -ServiceName $sqlServiceName
		}
		else
		{
			'[Get-SqlServiceStartupAccount] : [ERROR] failed to retrieve a ServiceName for the SQL Instance' -f $SqlInstanceName | WriteTo-StdOut
		}
        
   }
	else
	{
		'[Get-SqlServiceStartupAccount] : [ERROR] Required parameter: -SqlInstanceName: [{0}] was not specified' -f $SqlInstanceName | WriteTo-StdOut
	}
	return $sqlServiceStartupAcct
	
}

# Function : Get-ServiceStartupAccount 
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You can call this function from your PS script
#
# Description:
# 			Call this function to get the service startup Account for a given service name
# 
# Arguments:
#			$ServiceName is the windows service name (same as retruned from get-service or Get-CimInstance win32_service)
#
# Returns:
#			Service Startup Account
# 
# Owner:
#			muddin
#
# Revision History:
#
#           1.0 08/2012		muddin
#               Original Version 
#
Function Get-ServiceStartupAccount([string]$ServiceName)
{
	trap
    {
        '[Get-ServiceStartupAccount] : [ERROR] Trapped exception ...' | WriteTo-StdOut
        Report-Error    
    }
	
	[string]$svcStartupAccount = $null
			
	if ( $false -eq [System.String]::IsNullOrEmpty($ServiceName) )
    {
	   	# Get the Service with the Service Name
		$objService = Get-CimInstance win32_service | Where-Object {$_.Name -ieq $ServiceName}
		
		if ($null -ne $objService)
		{
			# get service account
	   		$svcStartupAccount = $objService.StartName
		}
		else
		{
			# No service Found with this ServiceName
			'[Get-ServiceStartupAccount] : [ERROR] No Service was found with the ServiceName: [{0}]' -f $ServiceName | WriteTo-StdOut
    }

	}
    else
     {
        '[Get-ServiceStartupAccount] : [ERROR] Required parameter -ServiceName was not specified' | WriteTo-StdOut
     }
	
	return $svcStartupAccount
	
}


# Function : Export-EnvVarsToXml
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You can call this function from your PS script
#
# Description:
# 			Call this function if you need an XML Output of Environment Variables collected in the context of current user.
#			
# Arguments:
#			[string]$ExportPath - Path where the XML output is saved.
#
# Returns:
#			void
# 
# Owner:
#			muddin
#
# Revision History:
#
#           1.0 07/2012    muddin
#               Original Version
#			1.1 12/2012
#				modified XML Output implementation
#
Function Export-EnvVarsToXml([string]$ExportPath)
{
	$Error.Clear()           
    trap 
    {
    	'[Export-EnvVarsToXml] : Trapped error ...' | WriteTo-StdOut
    	Report-Error
    }

	if ( $false -eq [System.String]::IsNullOrEmpty($ExportPath) )
	{
	# get-childitem env: returns System.Collections
	$AllEnvVars = get-childitem env:
		
		# XMLDocument
		[xml]$xmlEnvVariables = [xml]"<?xml version=""1.0"" encoding=""utf-8""?><EnvironmentVariables></EnvironmentVariables>"
		
		# Build XML Document using the Collection entries
		if ( $null -ne $AllEnvVars )
		{
	foreach ($EnvVar in $AllEnvVars)
	{
				# add each Property
				$elemEnvVar = $xmlEnvVariables.CreateElement("EnvironmentVariable")
				[Void]$xmlEnvVariables["EnvironmentVariables"].AppendChild($elemEnvVar)
						
				$attrName = $xmlEnvVariables.createAttribute("Name")
 				[Void]$elemEnvVar.setAttributeNode($attrName)
 				$elemEnvVar.setAttribute("Name", $EnvVar.Name)
			
				$attrValue = $xmlEnvVariables.createAttribute("Value")
 				[Void]$elemEnvVar.setAttributeNode($attrValue)
 				$elemEnvVar.setAttribute("Value", $EnvVar.Value)
		}
	}
	
		if ( $null -ne $xmlEnvVariables)
		{
			$xmlEnvVariables.Save($ExportPath)
		}
	}
	else
     {
		'[Export-EnvVarsToXml] : [ERROR] Required parameter -ExportPath was not specified' | WriteTo-StdOut
     }
	
}


# Function : Export-RegistryKeysToXml
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You can call this function from your PS script
#
# Description:
# 			Call this function if you need an XML Output of the values under a specific registry key 
#			For example, HKLM:\System\CurrentControlSet\Services\TCPIP\Parameters
#			NOTE: It doesn't traverse the subkeys, so add the all keys individually to the array like this
#			$KeysToExport = @()
#			$KeysToExport += "HKLM:\System\CurrentControlSet\Control\Lsa"
#			$KeysToExport += "HKLM:\System\CurrentControlSet\Control\Lsa\Kerberos\Parameters"
#
# Arguments:
#			[string[]]$RegistryKeysToExport - an Arrary of registry keys, to be exported
#			[string]$ExportPath - Path where the XML output is saved.
#			[string]$RootElementName - Root element name of the XML being generated
#
# Returns:
#			void
#			Function will create an Empty XML with Root element, if there are no keys to export
# 
# Owner:
#			aparnavi - original version (Export-Registry) in utils_RS
#			muddin - copied the code in a DSD util function with a new function name, to be re-used by any SQL product.
#
# Revision History:
#
#           1.0 06/2012    muddin
#               Original Version
#			1.1 12/2012
#				modified XML Output implementation
#
Function Export-RegistryKeysToXml ([string[]]$RegistryKeysToExport,[string]$ExportPath, [string]$RootElementName)
{ 
	$Error.Clear()           
    trap 
    {
    	'[Export-RegistryKeysToXml] : Trapped error ...' | WriteTo-StdOut
    	Report-Error
    }
	
	if ( ($null -eq $RegistryKeysToExport ) -or ( $true -eq [System.String]::IsNullOrEmpty($ExportPath) )`
		-or($true -eq [System.String]::IsNullOrEmpty($RootElementName) ) 
		)
{ 
		'[Export-RegistryKeysToXml] : [ERROR] One of Required parameters: RegistryKeysToExport, ExportPath, RootElementName was not specified' | WriteTo-StdOut
		return
	}
	
	#continue

	$data = @()
     #go through each pipelined path
    Foreach ($item in $RegistryKeysToExport) 
	{
		# include those registry entries that exist, else ignore
		if ($true -eq (Test-Path -Path $item))
		{
		 #get property names
         $properties= Get-ItemProperty -path $item | 
          #exclude the PS properties
          Select-Object * -Exclude PS*Path,PSChildName,PSDrive,PSProvider |
          Get-Member -MemberType NoteProperty,Property -erroraction "SilentlyContinue"
         
		 #enumrate each property getting itsname,value and type
         foreach ($property in $properties) 
		 {
             Write-Verbose "Exporting $property"
             $value=(get-itemproperty -path $item -name $property.name).$($property.name)
            if (-not ($properties))
             {
                 #no item properties were found so create a default entry
                 $value=$Null
                 $PropertyItem="(Default)"
                 $RegType="System.String"
             }
             else
             {
                 #get the registry value type
                 $regType=$property.Definition.Split()[0]
                 $PropertyItem=$property.name
             }
             #create a custom object for each entry and add it the temporary array
             $data += New-Object -TypeName PSObject -Property @{
                 	"RegistryKey"=$item
                 "Name"=$propertyItem
                 "Value"=$value
                 "Type"=$regType
                 	"ComputerName"=$env:computername
             }
         } #foreach $property
		} # Test-Path
     }#close Foreach 
	 
	#
	## Function will create an Empty XML with Root element, if there are no keys to export
	[xml]$xmlRegEntries = New-Object -TypeName xml
		
	# add the XML declaration section
	$xmlDecl = $xmlRegEntries.CreateXmlDeclaration("1.0","utf-8",$null)
		
	# Root element
	$rootElem = $xmlRegEntries.CreateElement($RootElementName)
 	[Void]$xmlRegEntries.AppendChild($rootElem)
     
	# Iterate though PSObeject Array $data, to add Registry entries to XMLDocument
    if ($null -ne $data)
    {
	 	foreach ($regEntry in $data)
		{
			# We are calling each registry entry as "RegistryEntry"
			$genericElem = $xmlRegEntries.CreateElement("RegistryEntry")
 			[Void]$rootElem.AppendChild($genericElem)
			
			#Path
			$Path = $xmlRegEntries.CreateElement("Path")
			$Path.psbase.InnerText = $regEntry.RegistryKey
 			[Void]$genericElem.AppendChild($Path)
			
			#Name
			$Name = $xmlRegEntries.CreateElement("Name")
			$Name.psbase.InnerText = $regEntry.Name
 			[Void]$genericElem.AppendChild($Name)
			
			#Type
			$Type = $xmlRegEntries.CreateElement("Type")
			$Type.psbase.InnerText = $regEntry.Type
 			[Void]$genericElem.AppendChild($Type)
			
			#Value
			$Value = $xmlRegEntries.CreateElement("Value")
			[Void]$genericElem.AppendChild($Value)
			
			if ( $null -ne $regEntry.Value)
			{
				# If registry value is Multi-value string, list each element of the array as an 'entry'
				if ( ($true -eq $regEntry.Value.GetType().IsArray ) -and ( "System.String[]" -ieq $regEntry.Value.GetType().FullName) )
				{
					foreach ($entry in $regEntry.Value)
					{
						$entryElem = $xmlRegEntries.CreateElement("Entry")
						$entryElem.psbase.InnerText = $entry
 						[Void]$Value.AppendChild($entryElem)
					}
				}
				else
				{
			 		$Value.psbase.InnerText = $regEntry.Value
				}
			}
			else
     {
				$Value.psbase.InnerText = ""
			}
			
 			#ComputerName
			$computerName = $xmlRegEntries.CreateElement("ComputerName")
			$computerName.psbase.InnerText = $regEntry.ComputerName
 			[Void]$genericElem.AppendChild($computerName)
		}	
			
	}
     else 
   	{
		'[Export-RegistryKeysToXml] : [Info] No Registry keys were found to be exported in XML.' | WriteTo-StdOut
    }
	
	# Save XMLDocument to xml file
	if ( $null -ne $xmlRegEntries)
	{
		$xmlRegEntries.Save($ExportPath)
    }
 
} #end Function

#
# Function : Test-Property
# ----------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You can call this function from your PowerShell scripts.  
#
# Description:
# 			This function is used to check if a property (NoteProperty) exists in a PSObject. In certain cases, PSObjects are created dynamically and depending on Product versions, the same PSObject 
#			Property may not exist -this function helps to check on that.
# 
# Arguments: [PSObject]$InputObject
#			 [string]$PropertyName
#			
#			
# Returns:
#			bool value indicating if the property exists in PSObject
# 
# Owner:
#			muddin
#
# Revision History:
#
#           1.0 12/2012		muddin
#               Original Version
# 
Function Test-Property( [PSObject]$InputObject, [string]$PropertyName )
{
	[bool]$propExists = $false
	
	if ( ($null -eq $InputObject ) -or ( $true -eq [System.String]::IsNullOrEmpty($PropertyName) ) )
	{
		'[Test-Property] : [ERROR] One of Required parameters: -InputObject, -PropertyName was not specified or invalid parameter was passed' | WriteTo-StdOut
	}
	else
	{
		if ( $null -ne $InputObject.PSObject.Members )
		{
			foreach($p in $InputObject.PSObject.Members | Where-Object {$_.MemberType -eq "NoteProperty"}) 
			{
				if ($p.Name -ieq $PropertyName)
				{
					$propExists = $true
					break
				}
			}
		}
	}
	
	return $propExists
}



# Function : Get-ServiceStatus
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - You can call this function from your PS script
#
# Description:
# 			Call this function to determine the current status of the SQL Server service for a given instance
# 
# Arguments:
#			$instance is the instance to check. Do not pass the instance name prepended with the machine name i.e. NetName\InstanceName
#
# Returns:
#			"Running" if the SQL Server service for the passed instance is running
#			"Stopped" if the SQL Server service for the passed instance is stopped
#			"Paused" if the SQL Server service for the passed instance is paused
#			
#			Can compare the return value to the following constants in your script. They are defined at the top of this file:
#			$SERVICE_STATUS_RUNNING
#			$SERVICE_STATUS_STOPPED
#			$SERVICE_STATUS_PAUSED
# 
# Owner:
#			DanSha 
#
# Revision History:
#
#           1.0 08/2011    DanSha
#               Original Version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#               Add .ToUpper() to strings that are target of comparison to avoild possible issues on case sensitive servers
#				Return service status as uppercase string to avoid comparison problems on case sensative servers
#
function Get-ServiceStatus ([string]$ServiceName)
{
    trap
    {
        '[Get-ServiceStatus] : [ERROR] Trapped exception ...' | WriteTo-StdOut
        Report-Error    
    }

    [string]$ServiceStatus=$null
    
    if ($null -ne $ServiceName)
    {
	   return ([string](Get-Service -Name $ServiceName | select-object -Property Status).Status).ToUpper()
    }
    else
    {
        '[Get-ServiceStatus] : [ERROR] Required parameter -ServiceName was not specified' | WriteTo-StdOut
    }
}

function Get-ServiceStatusSql([string]$Instance)
{
     trap
    {
        '[Get-ServiceStatusSql] : [ERROR] Trapped exception ...' | WriteTo-StdOut
        Report-Error    
    }

    [string]$ServiceStatus=$null
    
    if ($null -ne $instance)
    {
        if ( ($Instance.ToUpper() -eq 'DEFAULT') -or ($Instance.ToUpper() -eq 'MSSQLSERVER') ) {
    		$ServiceName = 'MSSQLSERVER'
    	} else {
    		$ServiceName = ('MSSQL$'+$Instance)
    	}
        
        $ServiceStatus=Get-ServiceStatus -ServiceName $ServiceName
    }
    else
    {
        'Get-ServiceStatusSql : [ERROR] Required parameter -Instance was not specified' | WriteTo-StdOut
    }
    
    return($ServiceStatus)
    
}

# Function : Get-SqlInstanceKey
# -----------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Private/Internal - Do not call this function from your PS script
#
# Description:
# 			This is a helper function used to determine the instance key name for a given named instance
# 
# Arguments:
#			$instance is the instance to lookup. Do not pass the instance name prepended with the machine name i.e. NetName\InstanceName
#			$RegKey is the key to perform the lookup under
#
# Returns:
#			The instance key for the named instance passed
# 
# Owner:
#			DanSha 
#
# Internal helper function for SQL registry access.  Do not call from your script
#
function Get-SqlInstanceKey( [string]$SqlInstance
                            ,[string]$regKey )
{
	# Get instance folder name under SQL Root directory
	#
    if ($true -eq (Test-Path -Path ($RegKey + '\Instance Names\SQL')))
	{
		(Get-ItemProperty -Path ($RegKey + '\Instance Names\SQL')).$SqlInstance
        
        # Did call to Get-ItemProperty succeed?
        if ($false -eq $?)
        {
           "[Get-SqlInstanceKey] : Get-ItemPropert failed to retrieve SQL instance key for SQL Server instance: {0}" -f $SqlInstance | WriteTo-StdOut
           Report-Error            
        }
	}
	else
	{
		# Log error message
		"[Get-SqlInstanceKey] : Unable to locate instance key for SQL Server instance: {0}" -f $SqlInstance | WriteTo-StdOut
        Report-Error
	}
}

# Function : Get-IsSqlInstanceClustered
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - Call this function from your PS script
#
# Description:
# 			This function determines whether the instance passed is clustered
#			This function is consumed and its output is exposed by the Enumerate-SqlInstances function.  
# 
# Arguments:
#			$instance is the instance to lookup. Do not pass the instance name prepended with the machine name i.e. NetName\InstanceName
#
# Returns:
#			$true if the instance is clustered
#			$false if the instance is not clustered
# 
# Owner:
#			DanSha 
#
# Revision History:
#
#           1.0 08/2011    DanSha
#               Original Version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#               Specify parameter names on function calls so as not to rely on positional paramters
#
function Get-IsSqlInstanceClustered([string]$SqlInstance)
{
    trap 
    {
    	'[Get-IsSqlInstanceClustered] : [ERROR] Trapped exception ...' | WriteTo-StdOut
    	Report-Error
    }

    # Check if required parameter was passed
	if ($null -ne $SqlInstance)
    {
        $InstanceRootKey = Get-SqlInstanceRootKey -SqlInstanceName $SqlInstance

    	# Did Get-SqlInstanceRootKey return a value? If we call Test-Path with a NULL argument it throws an exception
        if ($null -ne $InstanceRootKey)
        {
            # $InstanceRootKey is not null, but did it return a valid key?
            if ($true -eq (Test-Path -Path $InstanceRootKey))
        	{
        		# SQL2008, SQL2008R2, SQL2012
                #
                # NOTE: The ClusterState key only exists if the instance is clustered.  As such, if the below statement returns $false 
                #       it simply means that instance we are checking is not clustered
        		if ($true -eq (Test-Path -Path (Join-Path -Path $InstanceRootKey -ChildPath '\ClusterState')))
        		{ 
        			$IsClustered = (Get-ItemProperty -Path (Join-Path -Path $InstanceRootKey -ChildPath '\ClusterState')).SQL_Engine_Core_Inst
                    
                    # If Get-ItemProperty fails, report it here
                    if ($false -eq $?)
                    {
                        "[Get-IsSqlInstanceClustered] : [ERROR] Get-ItemPropery failed to retrieve ClusterSate for SQL Engine for SQL Server instance: [{0}]" -f $SqlInstance  | WriteTo-StdOut
                        Report-Error
                    }
        		} 
        		# SQL2005
                #
                # Check for clustered instance is different on SQL 2005
        		elseif ($true -eq (Test-Path -Path (Join-Path -Path $InstanceRootKey -ChildPath '\Setup')))
        		{
        			$IsClustered = (Get-ItemProperty -Path (Join-Path -Path $InstanceRootKey -ChildPath '\Setup')).SqlCluster		
                    
                    # If Get-ItemProperty failed, report it here ...
                    if ($false -eq $?)
                    {
                        "[Get-IsSqlInstanceClustered] : [ERROR] Get-ItemPropery failed to retrive ClusterSate for SQL Engine for SQL Server 2005 instance: [{0}]" -f $SqlInstance  | WriteTo-StdOut
                        Report-Error
                    }
        		}
        	}
            else
            {
                "[Get-IsSqlInstanceClustered] : [ERROR] Invalid instance root key: [{0}] for SQL Server instance: [{1}]" -f $InstanceRootKey, $SqlInstance  | WriteTo-StdOut
                Report-Error
            } 
    		
       }  #if ($null -eq $InstanceRootKey)
       else
       {
            "[Get-IsSqlInstanceClustered] : [ERROR] Get-SqlInstanceRootKey returned `$null for SQL Server instance: [{0}]" -f $SqlInstance | WriteTo-StdOut
       }
       
    } #if ($null -ne $SqlInstance)
    else
    {
        '[Get-IsSqlInstanceClustered] : [ERROR] Required parameter $SqlInstance is $null' | WriteTo-StdOut
    }
       
	return (1 -eq $IsClustered)	
}

# Function : Get-NetNameForSqlInstance
# ------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Private/Internal - Do not call this function from your PowerShell script
#
# Description:
# 			This function retrieves the netname for a given SQL Server instance.  For clustered instances, it returns the SQL network name
#			This function is consumed and its output is exposed by the Enumerate-SqlInstances function.  
# 
# Arguments:
#			$instance is the instance to lookup. Do not pass the instance name prepended with the machine name i.e. NetName\InstanceName
#
# Returns:
#			The NetName for the instance passed
# 
# Owner:
#			DanSha 
#
# Revision History:
#
#           1.0 08/2011    DanSha
#               Original Version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#               Added parameter metadata to make the parameter mandatory and validate that it's not null or empty
#
function Get-NetNameForSqlInstance ([string]$SqlInstance)
{
    trap 
    {
    	'[Get-NetNameForSqlInstance] : [ERROR] Trapped exception ...' | WriteTo-StdOut
    	Report-Error
    }

	if ($null -ne $SqlInstance)
    {
        # Retrieve root key for this instance
    	$InstanceRootKey = Get-SqlInstanceRootKey -SqlInstanceName $SqlInstance 
    	
    	if ($null -ne $InstanceRootKey)
        {
            if ($true -eq (Test-Path -Path (Join-Path -Path $InstanceRootKey -ChildPath '\Cluster')))
        	{ 
        		$SqlNetName = (Get-ItemProperty -Path (Join-Path -Path $InstanceRootKey -ChildPath '\Cluster')).ClusterName
                
                if ($false -eq $?)
                {
                    '[Get-NetNameForSqlInstance] : [ERROR] Get-ItemProperty failed to retrieve Sql cluster resource name' | WriteTo-StdOut
                    Report-Error
                }
            }
            else
            {
                $SqlNetName = $ComputerName
            }
            
        } # if ($null -ne $InstanceRootKey)
        else
        {
            "[Get-NetNameForSqlInstance] : [ERROR] Failed to retrieve instance root key for SQL Server instance: [{0}]" -f $SqlInstance | WriteTo-StdOut
            Report-Error
        }
    } #if ($null -ne $SqlInstance)
    else
    {
        '[Get-NetNameForSqlInstance] : [ERROR] Required parameter: $SqlInstance not supplied' | WriteTo-StdOut
    }
    
    return $SqlNetName
}

# Function : Get-SqlServerVersionString
# -------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Private/Internal - Do not call this function from your PowerShell script
#
# Description:
# 			This function retrieves the version string for a given SQL Server instance from the registry.  
#			This function is consumed and its output is exposed by the Enumerate-SqlInstances function.  
# 
# Arguments:
#			$instance is the instance you want the version string for. Do not pass the instance name prepended with the machine name i.e. NetName\InstanceName
#
# Returns:
#			The version string for the instance
# 
# Owner:
#			DanSha 
#
# Revision History:
#
#           1.0 08/2011    DanSha
#               Original Version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#               Added parameter metadata to make the $SqlInstance parameter mandatory and ensure that it's not passed as null or empty
#
function Get-SqlServerVersionString ([string]$SqlInstance)
{
	if ($null -ne $SqlInstance)
    {
        $InstanceRootKey = Get-SqlInstanceRootKey -SqlInstanceName $SqlInstance
    	
        if ($null -ne $InstanceRootKey)
        {
        	if ($true -eq (Test-Path -Path (Join-Path -Path $InstanceRootKey -ChildPath '\MSSQLServer\CurrentVersion')))
        	{ 
        		(Get-ItemProperty -Path (Join-Path -Path $InstanceRootKey -ChildPath '\MSSQLServer\CurrentVersion')).CurrentVersion
                
                if ($false -eq $?)
                {
                    "[Get-SqlServerVersionString] : [ERROR] Failed to retrieve CurrenVersion registry value for instance: [{0}]" -f $SqlInstance | WriteTo-StdOut
                    Report-Error
                }
        	}
        }
        else
        {
            "[Get-SqlServerVersionString] : [ERROR] Failed to retrieve instance root key for instance: [{0}]" -f $SqlInstance | WriteTo-StdOut
            Report-Error
        }
    }
    else
    {
        '[Get-SqlServerVersionString] : [ERROR] Required parameter: -SqlInstance was not specified' -f $SqlInstance | WriteTo-StdOut
    }
}


function Test-SupportedSqlServerVersion([object[]]$Instances)
{
    trap
    {
        '[Test-SupportedSqlServerVersion] : [ERROR] Trapped exception ...'
        Report-Error
    }
    
    # Populate this array with supported builds and return it to the caller
    $InstancesRunningSupportedBuild=@()
    
    if ($null -ne $Instances)
    {
        
        foreach ($Instance in $Instances)
        {
                       
            # Attempt to retrieve version information for each instance.  This will fail for a SQL 2000 default instance
            $VersionString=Get-SqlServerVersionString -SqlInstance $instance
                    
            if ($null -ne $VersionString)
            {
                $SqlVersionMajor, $SqlVersionMinor, $SqlBuild, $SqlRevision  = $VersionString.Split('.')
                
                if ($global:SQL:SQL_VERSION_MAJOR_SQL2005 -le $SqlVersionMajor)
                {
                    $InstancesRunningSupportedBuild+=@($Instance)
                }
                else
                {
                    "[Test-SupportedSqlServerVersion] : [WARN] Discarding instance: [{0}] SQL Major Version: [{1}] SQL Server 2005 is the minimum supported version." -f $Instance, $SqlVersionMajor | WriteTo-StdOUT
                }
               
            }
            else
            {
                "[Test-SupportedSqlServerVersion] : [WARN] Failed to retrieve version information for instance: [{0}] May be a SQL Server 2000 default instance.  SQL Server 2005 is the minimum supported version." -f $Instance | WriteTo-StdOUT
                "[Test-SupportedSqlServerVersion] : [WARN] Skipping processing for instance: [{0}]" -f $instance | WriteTo-StdOUT
            }
       }
       
   } # if ($null -eq $Instances
   else
   {
        '[Test-SupportedSqlServerVersion] : [ERROR] Required parameter -Instances not specified' | WriteTo-StdOUT
   }
   
  return @($InstancesRunningSupportedBuild)
  
} # function Test-SupportedSqlServerVersion()

# Function : Get-InstanceProperties
# ---------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Private/Internal - Do not call this function from your PowerShell script
#
# Description:
# 			This is a helper function called by Enumerate-SqlInstances to retreive and set property information about the instances installed on the machine.  
# 
# Arguments:
#			$instances is an array of instances to process
#           $retKeyToEnumerate is the registry key to perform the lookups from
#
#			NOTE that most information is retrieved from the registry. There is a code path to retrieve this information from the SQL 
#			Server PowerSell provider but these properties are not set for instances that are stopped
#
# Returns:
#			An array of hash tables with the following information for each instance:
#			InstanceName	: Instance name of the sql server instance
#			NetName			: NetName of the SQL instance. For a cluster this is the netname for the SQL cluster resource
#			IsClustered		: $true if the Instance is clustered.  $false if the instance is not clustered
#           ServiceStatus	: Status of the SQL Server service (Running, Stopped or Paused)
#			SqlVersionMajor	: Server major version 
#			SqlVersionMinor	: Minor SQL Server version
#			SqlBuild		: SQL Server build number
# 
# Owner:
#			DanSha 
#
# Function Visibility: Private (Do not call from your PowerShell script)
#
# Revision History:
#
#           1.0 08/2011		DanSha
#               Original Version
#			1.1 01/18/2012	DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#               Added parameter metadata which made both parameters mandatory and prevents the passing of null or empty arguments
#               Added "global" qualifier to default value for $regKeyToEnumerate argument
#               Added .ToUpper() to strings that are targets of comparison operations to avoid possible issues on case sensitive servers
#			1.2 02/03/2012	DanSha
#				Added trap handler
#
function Get-InstanceProperties ( [Object[]] $Instances
                                 ,[string]$RegKeyToEnumerate=$global:SqlServerRegKey )
{ 
    trap 
    {
    	'[Get-InstanceProperties] : [ERROR] Trapped exception ...' | WriteTo-StdOut
    	Report-Error
    }

	# An array of hashtables that's populated with information about each instance and returned to the caller
	$arrayofhashes = @()
	
    if ($null -ne $Instances)
    {
    	# Now collect information about each instance
    	#
    	foreach ($instance in $Instances)
    	{
    		# The SQL Server PS Provider enumerates the default instance as "DEFAULT".  However, the default instance
    		# is stored in the registry as "MSSQLSERVER"
    		# Translate DEFAULT to MSSQLSERVER before we do the regsitry lookup
    		#
    		if ($instance.ToUpper() -eq 'DEFAULT') {$instance = 'MSSQLSERVER'}
    		
    		# Figure out whether this instance is clustered or not
    		#
    		$IsClustered = Get-IsSqlInstanceClustered -SqlInstance $instance 
    		
            if (($true -eq $IsClustered) -or ($false -eq $IsClustered))
            {
        		# Now set netname for this instance
        		#
                $SqlNetName = Get-NetNameForSqlInstance -SqlInstance $instance
                
        		if ($null -eq $SqlNetName) 
        		{
        			"[Get-InstanceProperties] : [ERROR] Could not determine the Netname for clustered instance: {0}" -f $instance | WriteTo-StdOut
        		}
        		
        		# Retrieve the SQL Server Version in Major.Minor.Build.Revision format
        		# Then split the version string into its respective components [Major] [Minor] [Build] [Rev]
        		#
        		$SqlVersionMajor, $SqlVersionMinor, $SqlBuild, $SqlRevision  = Get-SqlServerVersionString -SqlInstance $instance | ForEach-Object {$_.Split('.')}
        		
        		$ServiceStatus = Get-ServiceStatusSql -instance $instance
        			
        		# If a default instance is present, report it as "DEFAULT" as opposed to MSSQLSERVER
        		# This is the way the SQL Server PowerShell provider expects the DEFAULT instance to be identified
        		#
        		if ($instance.ToUpper() -eq 'MSSQLSERVER') {$instance = 'DEFAULT'}
        		
        		$arrayofhashes += @(@{InstanceName=$instance; NetName=$SqlNetName; IsClustered=$IsClustered; ServiceStatus=$ServiceStatus; SqlVersionMajor=$SqlVersionMajor; SqlVersionMinor=$SqlVersionMinor; SqlBuild=$SqlBuild; SqlRevision=$SqlRevision})

        		"[Get-InstanceProperties] : [INFO] Found SQL Instance: [{0}] Net Name: [{1}] IsClustered: [{2}] ServiceStatus: [{3}] SqlVersionMajor: [{4}] SqlVersionMinor [{5}] SqlBuild: [{6}] SqlRevision: [{7}]" -f $instance, $SqlNetName, $IsClustered, $ServiceStatus, $SqlVersionMajor, $SqlVersionMinor, $SqlBuild, $SqlRevision | WriteTo-StdOut
            
           } # if ($null -eq $IsClustered)
           else
           {
                "[Get-InstanceProperties] : [ERROR] Unable to determine whether instance: [{0}] is clustered" -f $instance | WriteTo-StdOut
           } 

    	} # foreach ($instance in $instances)
        
    } # ($null -ne $instances)
    else
    {
        '[Get-InstanceProperties] : [ERROR] Required parameter $instances not present' | WriteTo-StdOut
    }
	
	return @($arrayofhashes)
}

function Enumerate-Instances([string]$KeyToEnumerate, [switch]$SilentMode)
{
    trap
    {
        '[Enumerate-Instances] : [ERROR] Trapped exception ...'
        Report-Error
    }
    
    # Array to store instance names
    $InstanceNames=@()
    
    if ($null -ne $KeyToEnumerate)
    {
        # For SQL Server $KeyToEnumerate is:
        # "HKLM:\Software\Microsoft\Microsoft SQL Server\Instance Names\SQL" 
        #
        if ($true -eq (Test-Path -Path $KeyToEnumerate -ErrorAction SilentlyContinue))
        {
            # Get the Instance Names/[SQL | OLAP | RS] key
            $InstanceKey = Get-Item -Path $KeyToEnumerate -ErrorAction SilentlyContinue
            
            if ($null -ne $InstanceKey)
            {   
               foreach ($InstanceName in $InstanceKey.Property) {$InstanceNames+=$InstanceName}
            }
        }
        else
        {
            if ($false -eq $SilentMode)
            {
                '[Enumerate-Instances] : [ERROR] Failed to retrieve registry key: [{0}]' -f $KeyToEnumerate | WriteTo-StdOut    
            }
        }
        
    }
    else
    {
        if ($false -eq $SilentMode)
        {
            '[Enumerate-Instances] : [ERROR] Required parameter -KeyToEnumerate was not specified' | WriteTo-StdOut
        }
    }

    return @($InstanceNames)
}


# Function : Enumerate-SqlInstancesWithPsProvider
# -----------------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# NOTE:
#			!! This function is currently disabled.  !!
#			The SQL Server PowerShell provider does correctly enumerate instances but I've encountered the following difficulties that
#			I am currently researching:
#			* Performance of the SQL Server PowerShell provider when trying to access properties of the SMO Server object returned by Get-ChildItem
#			  for instances that are stopped
#			* If the instance represented by the SMO Server object is stopped, all properties of the object seem to be null
#
# Visibility:
#			Private/Internal - Do not call this function from your PowerShell script
#
# Description:
# 			This is a helper function called by Enumerate-SqlInstances to enumerate instance information using the SQL Server PowerShell provider.
#			This function is currently disabled and will throw an exception indicating as much if called
# 
# Arguments:
#			None
#
# Returns:
#			An array of SMO Server objects representing instances installed on the machine it's run against
#			Note that the SQL Server PowerShell provider does not enumerate Wow6432 instances
# 
# Owner:
#			DanSha 
#
# Revision History:
#
#           1.0 08/2011    DanSha
#               Original Version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#
function Enumerate-SqlInstancesWithPsProvider 
{    
	# Cause script to terminate if this function is called
	#
	$ErrorActionPreference = 'Stop'
	throw '### Function: Enumerate-SqlInstancesWithPsProvider() is currently disabled ...'
	
	if ($true -eq $false)
	{
		$SqlInstanceInfo = @()
		
		#NOTE: This function outputs all instances installed on a given machine.  Do we want just running instances or a switch that supports that?
	    #
	    if ($true -eq (Check-SqlSnapinsAreLoaded)) 
	    {        
	        # Get the list of SQL Server Instances installed on this machine and then retrieve instance properties
	        #
	        $SqlInstances = Get-ChildItem -Path SQLSERVER:\SQL\$ComputerName 
			$SqlInstanceInfo = Get-InstanceProperties -Instances $SqlInstances
	    }
		
		return @($SqlInstanceInfo)
	}
}

# Function : Enumerate-SqlInstancesFromRegistry
# -----------------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Private/Internal - Do not call this function from your PowerShell script
#
# Description:
# 			This is a helper function called by Enumerate-SqlInstances to enumerate installed SQL Server instances from the registry
# 
# Arguments:
#			$RegKeyToEnumerate : This is the registry key to search for installed instances
#
# Returns:
#			An array of SQL Server instance names SMO Server objects representing instances installed on the machine it's run against
#			Calls the Get-InstanceProperties helper function to retrieve and set properties for each instance it finds
# 
# Owner:
#			DanSha 
#
# Revision History:
#
#           1.0 08/2011    DanSha
#               Original Version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#			1.2 02/03/2012 DanSha
#				Added a trap handler
#
function Enumerate-SqlInstancesFromRegistry([string]$RegKeyToEnumerate)
{
    trap 
    {
    	'[Enumerate-SqlInstancesFromRegistry] : Trapped exception ...' | WriteTo-StdOut
    	Report-Error 
    }

	# Used internally to store the instances enumerated from the registry
	$instances = @()
    
    # Populated by 
    $SupportedInstances = @()
    	
	# Array of hashtables 
	$InstanceInfo = @()
	
    # Was the expected parameter passed?
	if ($null -ne $RegKeyToEnumerate)
    {
		if ($true -eq (Test-Path -Path $RegKeyToEnumerate))
        {        
            # Enumerate instances
            $instances = @(Enumerate-Instances -KeyToEnumerate $RegKeyToEnumerate)
            
            # Filter out any instances that are not SQL Server 2005 or later
            $SupportedInstances = @(Test-SupportedSqlServerVersion -Instances $instances)
            
            if (($null -ne $SupportedInstances) -and (0 -lt $SupportedInstances.Count))
            {
    			$InstanceInfo = @(Get-InstanceProperties -Instances $SupportedInstances -RegKeyToEnumerate $RegKeyToEnumerate)
            }
            else
            {
                "[Enumerate-SqlInstancesFromRegistry] : [INFO] No SQL Server instances were discovered from: [{0}]" -f $RegKeyToEnumerate | WriteTo-StdOut
                Report-Error
            }
        }
    
    } #if ($null -ne $RegKeyToEnumerate)
    else
    {
        '[Enumerate-SqlInstancesFromRegistry] : [ERROR] Required parameter -RegKeyToEnumerate was not specified' | WriteTo-StdOut
    }
	
	return @($InstanceInfo)
}

# Function : Enumerate-SqlInstances
# ---------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public - Call this function from your PowerShell script
#
# Description:
# 			This is a helper function you can call to enumerate all of the SQL Server instances installed on the machine the function is 
#			run against
#
#			This function should be called by your scripts to enumerate SQL Server instances. If it doesn't return the information you require
#			contact DanSha for enhancements
# 
# Arguments:
#			$Offline : A switch parameter that directs the function whether to enumerate instances from the registry ("offline") or from 
#					   the SQL Server PowerShell provider ("online")
#
# Returns:
#			An array of hashtables with the following format:
#			InstanceName	: Instance name of the sql server instance
#			NetName			: NetName of the SQL instance. For a cluster this is the netname for the SQL cluster resource
#			IsClustered		: $true if the Instance is clustered.  $false if the instance is not clustered
#           ServiceStatus	: Status of the SQL Server service (Running, Stopped or Paused)
#			SqlVersionMajor	: Server major version 
#			SqlVersionMinor	: Minor SQL Server version
#			SqlBuild		: SQL Server build number
# 
# Owner:
#			DanSha 
#
# Revision History:
#
#           1.0 08/2011    DanSha
#               Original Version
#			1.1 01/18/2012 DanSha
#				Replaced double quotes with single quotes when variable expansion not desired.
#
function Enumerate-SqlInstances ([switch] $Offline) 
{          
    trap 
    {
    	'[Enumerate-SqlInstances] : [ERROR] Trapped exception ...' | WriteTo-StdOut
    	Report-Error
    }
		
	# This is an array of hash tables containing information about the instances enumerated
	#
	$InstanceInfo = @()
	

	# Disabling instance enumeration via the SQL Powershell provider for now
	#
	# Why?
	# * Still in the process of investigating how to properly use the SQL PowerShell provider for this purpose
	# * The SQL PS Provider enumerates all instances installed on the machine and returns an 
	#   SMO Server object for each installed instance ... good
	# * However, if the instance is not running the properties of that server object are null
	#	which is problematic as we need to give the user information about the server like Major and minor build, cluster status, etc.
	# * What compounds the problem is that it takes about 30 seconds to dereference a property of the Server class when the server that
	#	it represents is stopped.  This is probably a login timeout that's occurring.
	# 
	#if ($true -eq $false)
	#{
	#	# Is the SQL Server PowerShell Provider installed?
	#	#
	#	if ((Check-SqlSnapinsAreInstalled) -and ($Offline -eq $false))
	#    {	
	#		#SQL Server PowerShell Provider Installed ... enumerate instances using provider
	#		#
	#		$InstanceInfo = @(Enumerate-SqlInstancesWithPsProvider )
	#	}
	#}

    # First, test to be sure the SQL Server key exists
    if ($true -eq (Test-Path -Path $global:SQL:SqlServerInstalledInstancesKey))
    {
   		$InstanceInfo = @(Enumerate-SqlInstancesFromRegistry -RegKeyToEnumerate $global:SQL:SqlServerInstalledInstancesKey)
    }
    else
    {
        "[Enumerate-SqlInstances] : [INFO] SQL Server registry key: [{0}] was not found" -f $global:SQL:SqlServerInstalledInstancesKey | WriteTo-StdOut
    }
    
	# Now try to enumerate the Wow6432 instances if they exist.  Sql PS Provider doesn't enumerate those
	# Need to check for existence of existing Wow6432 instances first or function appends a null line to the output array
	#
	if ($true -eq  (Test-Path -Path $global:SQL:SqlServerWow6432InstalledInstancesKey))
	{
		$InstanceInfo += @(Enumerate-SqlInstancesFromRegistry -RegKeyToEnumerate $global:SQL:SqlServerWow6432InstalledInstancesKey)
	}
    else
    {
        "[Enumerate-SqlInstances] : [INFO] There are no Wow6432 SQL Server installations on server: [{0}] Wow6432Node instance Names key [{1}] was not found" -f $env:ComputerName, $global:SQL:SqlServerWow6432InstalledInstancesKey | WriteTo-StdOut
    }
    

	return @($InstanceInfo)
}

# Function : FindSQLDiskResource
# ------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public : Call this function from your PowerShell script
#
# Description:
#			This Function will take a Drive Letter Such as T: and look to see if it is Online and Owned By the current 
#			Node we are running on.  
#
#			This function should only be called for cluster disk resources.  
# 
# Arguments:
#			$SQLClusterDiskToSearchFor : Cluster drive in the formation <drive-letter>: For example "T:"
#
# Returns:
#			$true if the cluster disk resource is online and owned by the node this function is run against
#			$false if the disk resource is either offline or not currently owned by this node.  Both will prevent us from accessing the disk
# Owner:
#			ShonH
#
# Writen: 8/19/2011
# Revised: 01/18/2012 : Only use double quotes (") when variable expansion is desired. Changing others to single quotes
#
function FindSQLDiskResource 
{
	param( [string]$SQLClusterDiskToSearchFor )
	#[Void]$shell.Popup("Inside FindSQLDiskResource" + "`nSQLClusterDiskToSearchFor = " + $SQLClusterDiskToSearchFor )  
	#checking to See if OS is Lower than 2008 as Import-Module FailoverClusters does not exist
	"[FindSQLDiskResource] : Passed Parameter {0}" -f $SQLClusterDiskToSearchFor | WriteTo-StdOut

	if ($OSVersion.Major -le 6) #Older than Vista 
	{
		# For Testing Function
		# $SQLClusterDiskToSearchFor = "T:"

		#Variables used for determining if we need to collect logs (Depends on SQL cluster resource state and owners
		$SQLDiskResourceOnline = $false
		$SQLResourceOwnedByCurrentNode = $false
		$SQLResourceFound = $false 

		#Create Cluster COM Object
		$SQLClusterApplicationComObject = New-Object -ComObject MSCluster.ClusApplication
		
		#Connecting to Cluster Com Object on Local Node
		$CurrentNodeName = $Env:COMPUTERNAME
		$SQLClusterConnectionObject = $SQLClusterApplicationComObject.OpenCluster($CurrentNodeName)
		
		#Loop through each Cluster Resource in the Cluster
		Foreach($TempClusterResource in $SQLClusterConnectionObject.Resources)
		{
			#There is no MSCluster_Disk Type so need to look for all Physical Disk Resource Types Manually
			if($TempClusterResource.TypeName -eq "Physical Disk")
			{
				
				#For Each Cluster disk resource of Type "Physical Disk" Will get partition information 
				# [Shonh] Bug Fix - It is possible for each Disk resource to have more than One Partition so need to loop through each partition for the disk resource
				Foreach ($TempDiskPartitions in $TempClusterResource.Disk.Partitions)
				{
					 # See if the Current Partition matches our Selected Disk
					if($TempDiskPartitions.DeviceName.ToLower().Contains($SQLClusterDiskToSearchFor.ToLower()))
					{
						# See if the Disk Resource is owned by this node
						if($TempClusterResource.OwnerNode.Name.ToString().ToLower().Equals($CurrentNodeName.ToString().ToLower()))
						{
							$SQLResourceOwnedByCurrentNode = $true
							"[FindSQLDiskResource] : Setting SQLResourceOwnedByCurrentNode Value {0}" -f $SQLResourceOwnedByCurrentNode | WriteTo-StdOut

						} #End if($TempClusterResource.OwnerNode.Name.ToString().ToLower().Equals($CurrentNodeName.ToString().ToLower()))
						else
						{
							#Write-Output "The Resource IS NOT currently owned by this node"
							$SQLResourceOwnedByCurrentNode = $false
							"[FindSQLDiskResource] : Setting SQLResourceOwnedByCurrentNode Value {0}" -f $SQLResourceOwnedByCurrentNode | WriteTo-StdOut
						} #End Else
						
						# See if the Disk Resource is in an Online state. For Windows 2003 the Online state=2
						if($TempClusterResource.State -eq 2)
						{
							# Write-Output "The Resource Is Online"
							$SQLDiskResourceOnline = $true
							"[FindSQLDiskResource] : Setting SQLDiskResourceOnline Value {0}" -f $SQLDiskResourceOnline | WriteTo-StdOut

						}#End if($TempClusterResource.State -eq 2)
						else
						{
							# Write-Output "The Resource However is NOT Online"
							$SQLDiskResourceOnline = $false
							"[FindSQLDiskResource] : Setting SQLDiskResourceOnline Value {0}" -f $SQLDiskResourceOnline | WriteTo-StdOut
						} #End Else

						#Found SQL Resource So Will break out of loops
						$SQLResourceFound = $true
						break
							  
					} #end if ($TempDiskPartitions.DeviceName.ToLower().Contains($SQLClusterDiskToSearchFor.ToLower()))
				} #end Foreach ($TempDiskPartitions in $TempClusterResource.Disk.Partitions)

				if($SQLResourceFound)
				{
					#Break out of loop
					break
				}

			} # end if($TempClusterResource.TypeName -eq "Physical Disk")
		} # Foreach($TempClusterResource in $SQLClusterConnectionObject.Resources)
		
	} # end if ($OSVersion.Major -le 6) #Older than Vista 
	elseif ($OSVersion.Major -gt 6) #Vista and newer 
	{ 
		#Need to Import the FailoverClusters Module
		Import-Module FailoverClusters

		# Psuedo Return Values
		# While PowerShell does not have a return like C# for example we can see the Values of Variables outside
		# $SQLDiskResourceOnline If True means that this Node Owns the Disk Resource you are looking for
		# $SQLResourceOwnedByCurrentNode If True means that the resource is currently owned by this node. 
		# It is possible for $SQLResourceOwnedByCurrentNode to return false even if owned by this node if the resource is offline
		# This is because in an offline state it does not have a drive letter just a HardDisk Path i.e. \\?\GLOBALROOT\Device\Harddisk3\Partition 1

		$SQLDiskResourceOnline = $false
		$SQLResourceOwnedByCurrentNode = $false

		# Collect All Cluster Physical Disk Resources
		$ClusterPhysicalDiskResources = Get-ClusterResource | Where-Object{$_.ResourceType.name -eq 'Physical Disk'} | Select-Object Name
	  
		#If there are a list of disks in the $ClusterPhyisicalDiskResource Array than loop through each until we find our resource

		if ($null -ne $ClusterPhysicalDiskResources)
		{
			# Enumerate through all Cluster Disk Resources to find our specific disk
			foreach($TempDiskResourceName in $ClusterPhysicalDiskResources)
			{
				# Connect to the MSCLUSTER WMI interface
				$TempSQLDiskResource = Get-CimInstance MSCluster_Resource -Namespace root/mscluster | Where-object{$_.Name -eq $TempDiskResourceName.Name}
				# Run Query to find the disks that Match our Current $TempDiskResourceName
				$TempSQLDiskObject = Get-CimInstance -Namespace root/mscluster -Query "Associators of {$TempSQLDiskResource} Where ResultClass=MSCluster_Disk"
				# Run Query to Get Partition Information on Current Disk
				$TempSQLPartitionObject = Get-CimInstance -Namespace root/mscluster -Query "Associators of {$TempSQLDiskObject} Where ResultClass=MSCluster_DiskPartition"
				
				# See if the Current Partition matches our Selected Disk
				if (-not [string]::Compare($SQLClusterDiskToSearchFor,$TempSQLPartitionObject.Path,$true))
				{
					$TempCurrentSQLDiskResourceGroup = Get-ClusterResource $TempDiskResourceName.Name #| Select-Object Group
					# See if the Disk Resource is owned by this node
					if (-not [string]::Compare($TempCurrentSQLDiskResourceGroup.OwnerNode.Name,$Env:COMPUTERNAME,$true))
					{
						# Write-Output "The Resource IS currently owned by this node"
						$SQLResourceOwnedByCurrentNode = $true
						"[FindSQLDiskResource] : Setting SQLResourceOwnedByCurrentNode Value {0}" -f $SQLResourceOwnedByCurrentNode | WriteTo-StdOut

						$TempSQLDiskResourceState = Get-ClusterResource  $TempDiskResourceName.Name
						# Write-Output  $TempSQLDiskResourceState.State
						# Check to see if the Resource is online
						if ([string]::Compare($TempSQLDiskResourceState.State, 'Online',$true))
						{
								# Write-Output "The Resource However is NOT Online"
								$SQLDiskResourceOnline = $false
								"[FindSQLDiskResource] : Setting SQLDiskResourceOnline Value {0}" -f $SQLDiskResourceOnline | WriteTo-StdOut
						}
						else
						{
								# Write-Output "The Resource Is Online"
								$SQLDiskResourceOnline = $true
								"[FindSQLDiskResource] : Setting SQLDiskResourceOnline Value {0}" -f $SQLDiskResourceOnline | WriteTo-StdOut
						}
					}
					else
					{
						# Write-Output "The Resource IS NOT currently owned by this node"
						$SQLResourceOwnedByCurrentNode = $false
						"[FindSQLDiskResource] : Setting SQLResourceOwnedByCurrentNode Value {0}" -f $SQLResourceOwnedByCurrentNode | WriteTo-StdOut
					}
						
					break
				}#if (-not [string]::Compare($SQLClusterDiskToSearchFor,$TempSQLPartitionObject.Path,$true))

			}#foreach($TempDiskResourceName in $ClusterPhysicalDiskResources)
		
		}#if ($ClusterPhysicalDiskResources -ne $null)
	
	}# end elseif ($OSVersion.Major -ge 6) #Vista and newer 
	
	#[Void]$shell.Popup("About to Return from FindSQLDiskResource Function" + "`nParameter passed to Function SQLClusterDiskToSearchFor = " + $SQLClusterDiskToSearchFor + "`n`n Returning Values:"  + "`nSQLDiskResourceOnline = " + $SQLDiskResourceOnline + "`nSQLResourceOwnedByCurrentNode = " + $SQLResourceOwnedByCurrentNode ) 
	return ($SQLDiskResourceOnline -and $SQLResourceOwnedByCurrentNode)
}	

# Function : Create-FilePolicyObject
# ----------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public : This function is called by Initialize-DsdEnvironment when the utils_DSD shared function library is loaded
#
# Description:
#			This function will initialize our default file policy settings.  
#           The file policy settings are used by the DSD Copy-Item wrapper, Copy-FileSql, to collect the desired set of files that
#           honor the following criteria:
#           MaxFileSizeInBytes - Specifies the maximum size of a file we will copy in bytes
#           MaxFileCount - Specifies the maximum number of files we will copy
#           MaxFileAge - Specifies the maximum age in days of files we will collect. 
#                        Specifying date in days as opposed to date so that we can calculate the cutoff date in the locale of the target system
#           NumberErrorsAllowed - The copy routine keeps track of the number of files that encountered error upon copy. 
#                                 This property represents the number of errors that are permitted before the copy routine will return an error
#           MaxBytesToCopyUncompressed - This is the maximum number of MB that the copy routine will copy for a given call to the routine
#                                     Consider an example where:
#                                     MaxFileSizeInBytes is 100*1024*1024 
#                                     MaxMbToCopyUncompressed is 500MB 
#                                     MaxFileCount is 10
#
#                                     If you encounter five files that are 100MB in size, Copy-FileSql, will return before copying 10 files
#                                 
#
#           The set of files copied is the AND of the above property settings
#
#           NOTE:
#           This function creates the $FilePolicySettings object with DEFAULT values
#           Since different file types (SQL Server errorlogs, SQL Server XEL files, SQL Server minidump files) have differing compression ratios, 
#           you will want to implement a "Set" routine to set the default values for a given file type if the default values are not appropriate
#
#
#			This function is called automatically when utils_DSD (this file) is "dot sourced" into your TS_Main from Initialize-DsdEnvironment
# 
# Arguments:
#			None
#
# Returns:
#			Nothing ...
# Owner:
#			DanSha
#
# Revision History: 
#			1.0 02/19/2012		DanSha
#				Initial Version
#
function Create-FilePolicyObject ( [int64]$MaxFileSizeInBytes=$null
                                  ,[int]$MaxFileCount=$null
                                  ,[int]$MaxFileAge=$null
                                  ,[int]$NumberErrorsAllowed=$null
                                  ,[int64]$MaxBytesToCopyUncompressed=$null
                                  ,[string]$FilePolicyName=$null
                                  ,[bool]$Initialized=$true )
{

	# Clear error collection at entry so that if an error occurs only relevant information will be reported upon failure
    $Error.Clear()
    
    trap 
    {
		'[Create-FilePolicyObject] : [ERROR] trapped exception ...' | WriteTo-Stdout
		Report-Error
        
        # Abort
        # break       
    }
	 
    # Create file policy object. By default allow the same number of errors as files 
    $FilePolicy = New-Object PsObject 
    
    # Did New-Object fail?
    #
    if (($false -eq $?) -or ($null -eq $FilePolicy))
    {
        '[Create-FilePolicyObject] : Unable to initialize the DSD file policy settings object' | WriteTo-StdOut
        Report-Error
        
        # What should I do here?  Should I throw an exception and abort?
        #
        # THROW '[Create-FilePolicyObject] : Unable to initialize 
    }
    
    # Add FilePolicy object properties ...
    $FilePolicy | Add-Member -MemberType NoteProperty -Name FilePolicyName -Value $FilePolicyName
    $FilePolicy | Add-Member -MemberType NoteProperty -Name MaxFileSizeInBytes -Value $MaxFileSizeInBytes
    $FilePolicy | Add-Member -MemberType NoteProperty -Name MaxFileCount -Value $MaxFileCount
    $FilePolicy | Add-Member -MemberType NoteProperty -Name MaxFileAge -Value $MaxFileAge
    $FilePolicy | Add-Member -MemberType NoteProperty -Name NumberErrorsAllowed -Value $NumberErrorsAllowed
    $FilePolicy | Add-Member -MemberType NoteProperty -Name MaxBytesToCopyUncompressed -Value $MaxBytesToCopyUncompressed
    $FilePolicy | Add-Member -MemberType NoteProperty -Name Initialized -Value $Initialized
    
    if ($null -ne $FilePolicy)
    {
        "[Create-FilePolicyObject] : [INFO] FilePolicyName: [{0}] `
                                             MaxFileSizeInBytes: [{1}] `
                                             MaxFileCount: [{2}] `
                                             MaxFileAge: [{3}] `
                                             NumberErrorsAllowed: [{4}] `
                                             MaxBytesToCopyUncompressed: [{5}] `
                                             Initialized: [{6}]" `
                                             -f $FilePolicy.FilePolicyName `
                                             , $FilePolicy.MaxFileSizeInBytes `
                                             , $FilePolicy.MaxFileCount `
                                             , $FilePolicy.MaxFileAge `
                                             , $FilePolicy.NumberErrorsAllowed `
                                             , $FilePolicy.MaxBytesToCopyUncompressed `
                                             , $Initialized  | WriteTo-StdOut
    }
                                                 
    return $FilePolicy
    
}

function Report-FilePolicySettings ([PSObject]$FilePolicy)
{
    if ($null -ne $FilePolicy)
    {
        
        "[Report-FilePolicySettings] : [INFO] The current file policy settings are: `
                                              FilePolicyName: [{0}] `
                                              MaxFileSizeInBytes: [{1}] `
                                              MaxFileCount: [{2}] `
                                              MaxFileAge: [{3}] `
                                              NumberErrorsAllowed: [{4}] `
                                              MaxBytesToCopyUncompressed: [{5}] `
                                              Initialized: [{6}]" `
                                            -f $FilePolicy.FilePolicyName  `
                                             , $FilePolicy.MaxFileSizeInBytes `
                                             , $FilePolicy.MaxFileCount `
                                             , $FilePolicy.MaxFileAge `
                                             , $FilePolicy.NumberErrorsAllowed `
                                             , $FilePolicy.MaxBytesToCopyUncompressed `
                                             , $FilePolicy.Initialized  | WriteTo-StdOut
    }
    
}

function Subtract-Days ([System.DateTime]$Date, [int]$Days=0)
{
    trap [System.ArgumentOutOfRangeException]
    {
        "[Subtract-Days] : [ERROR] Trapped System.ArugmentOutOfRangeException. Date: [{0}] Days [{1}]" -f $Date, $Days | WriteTo-StdOut
        Report-Error
        
        $Error.Clear()        
        
        break;
    }
    
    if ($null -eq $Date)
    {
        $Date = Get-Date    
    }
    
    # Days should not be negative
    if (0 -le $Days)
    {
        $Days_TimeSpan = New-Object -TypeName System.TimeSpan -ArgumentList $Days, 0, 0, 0, 0
        
        # If New-Object command succeeded
        if ($true -eq $?)
        {
            $Date = $Date.Subtract($Days_TimeSpan)            
        }
        
    }
    else
    {
         '[Subtract-Days] : [ERROR] Parameter specified for -Days cannot be negative' | WriteTo-StdOut
    }
    
    
    return $Date
    
}

function Enumerate-FilesUsingFilePolicy( [string]$SourcePath, [PSObject]$FilePolicy, [string]$FileFilter)
{

    trap
    {
        '[Enumerate-FilesUsingFilePolicy] : [ERROR] Caught exception ...'
        Report-Error

        # Now that we've reported on errors, clear the error collection
        $Error.Clear()
        
        $NumberOfErrors += 1
        
        if ($NumberOfErrors -gt $FilePolicy.NumberErrorsAllowed)
        {
            # Unwind the stack as we have exceeded the number of allowable errors/exceptions
            break
        }
         
    }
    
    [int]$NumberOfErrors = 0
    # Check if required parameter, -SourcePath was specified
    if ($null -ne $SourcePath)
    {
        # Valid -SourcePath?
        if ($true -eq (Test-Path -Path $SourcePath))
        {
            # Check if required parameter -FileSpec was specified
            if ($null -ne $FileFilter)
            {
                "[Enumerate-FilesUsingFilePolicy] : [INFO] Enumerating files from source path: [{0}] using FileFilter: [{1}]" -f $SourcePath, $FileFilter | WriteTo-StdOut
            
                # Check if required parameter -FilePolicy was specified
                if ($null -ne $FilePolicy)
                {
                    # Write in-force FilePolicy settings to stdout.log
                    Report-FilePolicySettings -FilePolicy $FilePolicy                                                                 
         
                    # If MaxFileAge is 0 or less file collection is not limited by age
                    if ((0 -lt $FilePolicy.MaxFileAge) -and ($null -ne $FilePolicy.MaxFileAge))
                    {
                        # Calculate StartDate from FilePolicy
                        $StartDate = Subtract-Days -Date (Get-Date) -Days $FilePolicy.MaxFileAge      
                    }
                    else
                    {
                        # Returns earliest possible DateTime value supported by .NET DateTime type : Monday, January 01, 0001 12:00:00 AM
                        $StartDate = New-Object -TypeName System.DateTime
                    }
                    
                    [int]$CountOfCopiedFiles=0
                    [int64]$CountOfCopiedBytes=0                
                    [bool]$bMeetsFilePolicyMaxFileCount=$true
                    [bool]$bMeetsFilePolicyNumberErrorsAllowed=$true                    
                
                    $Files = @(get-childitem -Path (Join-Path -Path $SourcePath -ChildPath "*") -Include $FileFilter  | `
                     sort-object -Property LastWriteTime -Descending | `
                     where-object {$_.LastWriteTime -gt $StartDate}  | `
                     foreach-object `
                     {                             
                            # Set/re-set MaxFileSizeFlag
                            [bool]$bMeetsFilePolicyMaxSize=$true
                            [bool]$bMeetsFilePolicyMaxCollectedBytes=$true
                                                        
                            # Evaluate the MaxFileSize against the size of the current file to see if it should be included
                            # A null MaxFileSize indicates that we do not want to restrict collection by file size
                            # null and 0 are overloaded to indicate that we do not wich to limit collection by file size
                            if (($null -ne $FilePolicy.MaxFileSizeInBytes) -and (0 -lt $FilePolicy.MaxFileSizeInBytes))
                            {
                                # Compare file size (converted to MB) to the MaxFileSizeInBytes policy setting
                                if ($_.Length -gt $FilePolicy.MaxFileSizeInBytes)
                                {
                                    # Skip this file ...
                                    $bMeetsFilePolicyMaxSize=$false
                                }
                            }
                           
                            # No Max bytes to collect specified
                            # 0 and null are overloaded to indicate that we do not want to limit th max uncompressed bytes
                            if (($null -ne $FilePolicy.MaxBytesToCopyUncompressed) -and (0 -lt $FilePolicy.MaxBytesToCopyUncompressed))
                            {
                                # Dividing by 1MB converts BYTES to MB
                                if ($FilePolicy.MaxBytesToCopyUncompressed -lt ($CountOfCopiedBytes + $_.Length) )
                                {
                                    # Skip this file ... will cause us to exceed MaxBytesToCopyUncompressed FilePolicy
                                    $bMeetsFilePolicyMaxCollectedBytes=$false
                                }
                            }
                            
                            # If we copy this file will we exceed the maximum file count?
                            # In this case we do not overload 0 to have special meaning. This allows us to have a mechanism to disable 
                            # collection of a given file type
                            if (($null -ne $FilePolicy.MaxFileCount) -and ($true -eq $bMeetsFilePolicyMaxFileCount))
                            {
                                if ($FilePolicy.MaxFileCount -lt ($CountOfCopiedFiles + 1))
                                {
                                    $bMeetsFilePolicyMaxFileCount=$false
                                }   
                                
                            }
                            
                            # Have we exceeded the maximum number of files allowed?
                            # A setting of zero or null means we don't want to limit file collection by the number of allowed errors
                            if (($null -ne $FilePolicy.NumberErrorsAllowed) -and (0 -lt $FilePolicy.NumberErrorsAllowed))
                            {
                                if (($NumberOfErrors -gt $FilePolicy.NumberErrorsAllowed) -and ($true -eq $bMeetsFilePolicyNumberErrorsAllowed))
                                {
                                    $bMeetsFilePolicyNumberErrorsAllowed=$false
                                }
                            }
                            
                            # Do we add it to the $Files array?
                            if  (($true -eq $bMeetsFilePolicyMaxSize) `
                            -and ($true -eq $bMeetsFilePolicyMaxCollectedBytes) `
                            -and ($true -eq $bMeetsFilePolicyMaxFileCount) `
                            -and ($true -eq $bMeetsFilePolicyNumberErrorsAllowed))
                            {
                                # Increment counters used to track copied files
                                $CountOfCopiedBytes += $_.Length
                                $CountOfCopiedFiles += 1
                                # Include file in list of files to copy
                                Join-Path $_.DirectoryName $_.Name 
                                
                                if ($true -eq $global:SQL:debug)
                                {
                                    "[Enumerate-FilesUsingFilePolicy] : [DEBUG] INCLUDING file: [{0}] `
                                                                                File Size: [{1}] `
                                                                                Count of copied files: [{2}] `
                                                                                Collected Bytes: [{3}] `
                                                                                Number of errors: [{4}] `
                                                                                File creation date: [{5}] `
                                                                                Start Date: [{6}]" `
                                                                               -f $_.Name `
                                                                                , $_.Length `
                                                                                , $CountOfCopiedFiles `
                                                                                , $CountOfCopiedBytes `
                                                                                , $NumberOfErrors `
                                                                                , $_.LastWriteTime `
                                                                                , $StartDate | WriteTo-StdOut
                                 } #if ($true -eq $global:SQL:debug)
                                                                                
                           } # if  (($true -eq $bMeetsFilePolicyMaxSize)
                           else
                           {

                                "[Enumerate-FilesUsingFilePolicy] : [INFO] SKIPPING file: [{0}] `
                                                                            File Size: [{1}] `
                                                                            Count of copied files: [{2}] `
                                                                            Collected bytes: [{3}] `
                                                                            Number of errors: [{4}] `
                                                                            File creation date: [{5}] `
                                                                            Start Date: [{6}] `
                                                                            MeetsFilePolicyMaxFileSize: [{7}] `
                                                                            MeetsFilePolicyMaxCollectedBytes: [{8}] `
                                                                            MeetsFilePolicyMaxFileCount: [{9}]" `
                                                                            -f $_.Name `
                                                                            , $_.Length `
                                                                            , $CountOfCopiedFiles `
                                                                            , $CountOfCopiedBytes `
                                                                            , $NumberOfErrors `
                                                                            , $_.LastWriteTime `
                                                                            , $StartDate `
                                                                            , $bMeetsFilePolicyMaxSize `
                                                                            , $bMeetsFilePolicyMaxCollectedBytes `
                                                                            , $bMeetsFilePolicyMaxFileCount | WriteTo-StdOut

                           }
                            
                      } ) 
   
                
                } # if ($null -ne $FilePolicy)
                else
                {
                    '[Enumerate-FilesUsingFilePolicy] : [ERROR] Required parameter -FilePolicy was not specified' | WriteTo-StdOut
                }
                
            } # if ($null -ne $FileSpec)
        
        }
        else
        {
            "[Enumerate-FilesUsingFilePolicy] : [ERROR] Invalid path [{0}] specified on -SourcePath parameter" -f $SourcePath | WriteTo-StdOut
            "[Enumerate-FilesUsingFilePolicy] : [INFO] If the path resides on a drive that is a cluster resource, the drive may be online to another cluster node" | WriteTo-StdOut
            Report-Error
        }
        
    } # if ($null -eq $SourcePath)
    else
    {
        '[Enumerate-FilesUsingFilePolicy] : [ERROR] Required parameter -SourcePath was not specified' | WriteTo-StdOut
    }
    
    return @($Files)
}

function Copy-FileSql (   [string]$SourcePath `
                        , [object[]]$FileFilters `
                        , [PSObject]$FilePolicy `
                        , [string]$InstanceName `
                        , [string]$LCID `
                        , [string]$SectionDescription `
                        , [switch]$RenameCollectedFiles `
						, [switch]$CompressCollectedFiles `
						, [string]$ZipArchiveName
                        , [switch]$EnumerateOnly )
{
	
    # Keep track of errors that occur during file copy
    [int64]$ErrorCount=0
    # Count number of files successfully collected
    [int64]$CountOfCollectedFiles=0
    
    trap 
	{
		'[Copy-FileSql] Trapped exception ...' | WriteTo-Stdout
		Report-Error
	    
	    # Now that we have reported all exceptions in this error object, Clear the errors collection
	    #
	    $Error.Clear()
	    
		if ((++$ErrorCount) -gt $FilePolicy.NumberErrorsAllowed)      
		{
			# Unwind the stack.  Max number of permitted errors surpassed
			break
		}
		
		continue
	}

    # If no file policy was specified force the default policy read in off configuration file
    if ($null -eq $FilePolicy)
    {
       $FilePolicy = $global:SQL:FILE_POLICY_SQL_SERVER_DEFAULT
    }
    
    # Checking for required parameter -FileFilter
    if (($null -ne $FileFilters) -and (0 -lt $FileFilters.Count))
    {
        # Checking for required parameter -FilePolicy
        if ($null -ne $FilePolicy)
        {
           if ($null -ne $SourcePath)
           {
                if ($null -ne $InstanceName)
                {
                
                   "[Copy-FileSql] : [INFO] Called with arguments -SourcePath: [{0}] -InstanceName: [{1}] -CompressCollectedFiles: [{2}] -EnumerateOnly: [{3}]" `
                                                           -f $SourcePath, $InstanceName, $CompressCollectedFiles, $EnumerateOnly | WriteTo-StdOut
                                                           
                   # Declare $Files array
                   $Files = @()
                   foreach( $FileFilter in $FileFilters )
                   {
                       $Files += @(Enumerate-FilesUsingFilePolicy -SourcePath $SourcePath -FileFilter $FileFilter -FilePolicy $FilePolicy -Instance $InstanceName)                  
                   }
                   
                    # Check if any files were enumerated. If so, proceed
                    if (($null -ne $Files) -and (0 -ne $Files.Count))
                    {
                        
                        # If -EnumerateOnly, return before collecting any of the enumerated files
						if ($false -eq $EnumerateOnly)
                        {
                            # If rename is not requested, the enumerated files have to be compressed (zip archive has SQL naming standard applied)
							# This is the default as it is ~30% faster than renaming and then compressing the files
                            if ($false -eq $RenameCollectedFiles)
							{
								CompressCollectFiles -FilesToCollect $Files -DestinationFileName $ZipArchiveName -SectionDescription $SectionDescription 
                                $CountOfCollectedFiles = $Files.Count
							}
							else
							{
								# First, rename the individual enumerated files ... which requires a copy from the source to the destination folder for each file
								$FilesToCollect=@()
								$FilesToCollect=@(CopyAndRename-Files -SourceFiles $Files -InstanceName $InstanceName -FilePolicy $FilePolicy -LCID $LCID)
							
								# If we need to compress the renamed files, do that here ...
								if (($null -ne $FilesToCollect) -and (0 -lt $FilesToCollect.Count))
								{
									if ($true -eq $CompressCollectedFiles)
									{
										CompressCollectFiles -FilesToCollect $FilesToCollect -DestinationFileName $ZipArchiveName -SectionDescription $SectionDescription 
	   								}
									else
									{
									   # Compression not required.  Just collect the files we've already copied to the destination folder when they were "renamed".

									   # Collect the files
	                                   CollectFiles -FilesToCollect $FilesToCollect -SectionDescription $SectionDescription -FilePolicy $FilePolicy
								    }									
									
								}	# if (($null -ne $FilesToCollect) -and (0 -lt $FilesToCollect.Count))
								
							}	#else

                            "[Copy-FileSql] : [INFO] [{0}] files were collected from source folder: [{1}]" -f $FilesToCollect.Count, $SourcePath | WriteTo-StdOut
                            
                        } #if ($false -eq $EnumerateOnly) 
                        
                   } # if if (($null -ne $Files) -and (0 -ne $Files.Count))
                   else
                   {
                   		'[Copy-FileSql] : [INFO] No files were found that met the specified filter criteria: [{0}] in folder: [{1}]' -f $FileFilter, $SourcePath | WriteTo-StdOut                            
                   }
                   
                } # if ($null -eq $Instance)
                else
                {
                    '[Copy-FileSql] : [ERROR] Required parameter -Instance was not specified or it''s value was null' | WriteTo-StdOut            
                }
                 
                             
            } # if ($null -eq $SourcePath)
            else
            {
                '[Copy-FileSql] : [ERROR] Required parameter -SourcePath was not specified or it''s value was null' | WriteTo-StdOut            
            }
               
        
        } # if ($null -ne $FilePolicy)
        else
        {
            '[Copy-FileSql] : [ERROR] Required parameter -FilePolicy was not specified or it''s value was null' | WriteTo-StdOut
        }
    
    } # if (($null -ne $FileFilters) -and (0 -lt $FileFilters.Count))
    else
    {
         '[Copy-FileSql] : [ERROR] Required parameter -FileFilters was not specified or it''s value was null' | WriteTo-StdOut
    }
    
  return @($Files)
  
} # Copy-FileSql


function CopyAndRename-Files ( [Object[]]$SourceFiles `
						     , [string]$InstanceName `
							 , [PSObject]$FilePolicy `
                             , [string]$LCID)
{
	
	trap 
	{
		'[CopyAndRename-File] Trapped exception ...' | WriteTo-Stdout
		Report-Error

        # When continuing from a trapped exception at this scope the function, will return to the caller		
		continue
	}
	
	# Keep track of copied and renamed files so that they can be later collected
	$FilesToCollect=@()
	[Int64]$CountOfCollectedFiles=0
	[Int64]$CountOfErrors=0
		
	if (($null -ne $SourceFiles) -and (0 -lt $SourceFiles.Count))
	{
		if ($null -ne $InstanceName)
		{
			foreach($File in $SourceFiles)
		    {
		        
                # Generate the OutFileName that meets the SQL naming standard:
    		    # <COMPUTER_NAME>_<INSTANCE_NAME>_<LCID>_RootFileName[.ext]
                if ($null -ne $LCID)
                {
    		        $OutFileName = "{0}_{1}_{2}_{3}" -f $env:ComputerName `
    		                                          , $InstanceName `
    		                                          , $LCID `
    		                                          , (Split-Path -Leaf -Path $File)
                }
                else
                {
                    # I don't know whether the LCID is applicable to all file types (like binary files or XML files)
                    # so providing a way to omit the LCID from the name 
    		        $OutFileName = "{0}_{1}_{2}" -f $env:ComputerName `
		                                          , $InstanceName `
		                                          , (Split-Path -Leaf -Path $File)
                
                }
		                                                
				# Build destination path for Copy-Item call
			    $DestinationPath = Join-Path -Path $PWD.Path -ChildPath $OutFileName
				
		        # $File should be valid as we just enumerated the file but check again to be safe
		        if ($true -eq (Test-Path -Path $File -PathType Leaf))
		        {
		            # Following a trapped/handled exception, execution resumes at the next statement in the same scope as the trap statement
                    # As such, we need to trap exceptions raised by Copy-Item within the scope where the copy occurs
                    trap 
                    { 
                        Report-Error
                        Continue
                    }
                    
                    # $File is full path to source file	
					Copy-Item -Path $File -Destination $DestinationPath -Force -ErrorAction SilentlyContinue
		            
		            # Did the copy succeed?
		            if ($true -eq $?)
		            {
		                $FilesToCollect += @($DestinationPath)
		                
		                # Debug output to record successful file copy operations ...
		                if ($true -eq $global:SQL:debug)
		                {
							$CountOfCollectedFiles += 1
		                    "[CopyAndRename-File] : [DEBUG] Copy complete. SourcePath: [{0}] DestinationPath: [{1}]" -f $File, $DestinationPath | WriteTo-StdOut
		                    "[CopyAndRename-File] : [DEBUG] Count of copied files is: [{0}]" -f $CountOfCollectedFiles | WriteTo-StdOut
		                }
						
		    		}
					else
					{
						# Copy-Item failed. Increment error count
                        $ErrorCount += 1
                        "[CopyAndRename-File] : [ERROR] Failed to copy and rename file ... `
                        Source File: [{0}] `
                        Destination File: [{1}] `
                        Current error count is: [{2}]
                        Current file policy allows: [{3}] errors before the copy operation will be terminated" -f $File, $DestinationPath, $ErrorCount, $FilePolicy.NumberErrorsAllowed | WriteTo-StdOut						
					}
					
				}	# if ($true -eq (Test-Path -Path $File -PathType Leaf))
				else
				{
                    "[CopyAndRename-File] : [ERROR] Invalid source path discovered in list of enumerated files: [{0}]" -f $File | WriteTo-StdOut
                    $ErrorCount += 1
				}
				
				# Check if the maximum number of errors allowed by file policy has been exceeded
                if ($FilePolicy.NumberErrorsAllowed -lt $ErrorCount)
                {
                	"[CopyAndRename-File] : [ERROR] The maximum number of errors allowed by the file policy: [{0}] has been exceeded.  Current error count is: [{1}]" -f $FilePolicy.NumberErrorsAllowed, $ErrorCount | WriteTo-StdOut						
                    '[CopyAndRename-File] : [ERROR] File copy operation is terminating' | WriteTo-StdOut						
                    break
					
                }	# if ($FilePolicy.NumberErrorsAllowed -lt $ErrorCount)
				
			} 	# foreach($File in $Files)
			
		}	# if ($null -ne $InstanceName)
		else
		{
			'[CopyAndRename-Files] : [ERROR] Required parameter -InstanceName was not specified' | WriteTo-StdOut
		}
	}	# if (($null -ne $SourceFiles) -and (0 -lt $SourceFiles.Count))
	else
	{
		'[CopyAndRename-Files] : [ERROR] Required parameter -SourceFiles was not specified' | WriteTo-StdOut
	}
	
	return @($FilesToCollect)
	
} # CopyAndRename-Files
function Initialize-FilePolicyConfiguration([PSOBJECT]$Policy)
{
    if ($null -ne $Policy)
    {
        return (  Create-FilePolicyObject -MaxFileSizeInBytes $Policy.MaxFileSizeInBytes `
                                          -MaxFileCount $Policy.MaxFileCount `
                                          -MaxFileAge $Policy.MaxFileAge `
                                          -NumberErrorsAllowed $Policy.NumberErrorsAllowed `
                                          -FilePolicyName $Policy.Name `
                                          -MaxBytesToCopyUncompressed $Policy.MaxBytesToCopyUncompressed  )
    }
    else
    {
        '[Set-FilePolicyConfiguration] : [ERROR] Required parameter -FilePolicy was not specified' | WriteTo-StdOut
    }

}

function Load-DebugAndTraceFlagSettings()
{
    trap
    {
        '[Load-DebugAndTraceFlagSettings] : [ERROR] Trapped exception ...'
        Report-Error
    }
    
    $ConfigFileFullPath = Join-Path -Path $PWD -ChildPath $global:SQL:PSSDIAGXML
        
    # Read debug and trace settings from PSSDIAG.XML 
    if ($true -eq (Test-Path -Path $ConfigFileFullPath -PathType Leaf))
    {
        $xml=[xml](Get-Content -Path $ConfigFileFullPath)
        
        if ($null -ne $xml)
        {
            # Load the Debug and Trace configuration from the configuration file
            $DebugAndTraceConfiguration=$xml.dsConfig.Collection.Machines.Machine.MachineCollectors.Policy.Debug
            
            if ($null -ne $DebugAndTraceConfiguration)
            {
                # We have a debug flag we create in the SQL namespace so that we can control the behavior of our scripts with 
                # no unexpected side affects caused by other script authors setting $debug to $true or $false
                #
                # Note: Have to use ToString() to perform the comparison because the value comes in off the Config file as a string (not a BOOL)
                # 
                if ($true.ToString() -eq $DebugAndTraceConfiguration.SqlDebugEnabled)
                {
                    # Enable private SQL debug switch.  
                    
                    # Note: That it is necessary to assigned the bool $true as opposed to $DebugAndTraceConfiguration.SqlDebugEnabled
                    # $DebugAndTraceConfiguration.SqlDebugEnabled is a string, and casting a non-null string to a bool always results in a $true value
                    $global:SQL:Debug = [bool]$true
                    
                }
                elseif ($false.ToString() -eq $DebugAndTraceConfiguration.SqlDebugEnabled)
                {
                    # Disable private SQL debug switch.
                    
                    # Note: 
                    # It's necessary to assigned the bool $true as opposed to $DebugAndTraceConfiguration.SqlDebugEnabled
                    # $DebugAndTraceConfiguration.SqlDebugEnabled is a string, and casting a non-null string to a bool always results in a $true value  
                    $global:SQL:Debug = [bool]$false
                    
                }
                else
                {
                    "[Load-DebugAndTraceFlagSettings] : [ERROR] Null or invalid SQL:debug configuration: [{0}] found in debug configuration file: [{1}]" -f $DebugAndTraceConfiguration.SqlDebugEnabled, $gobal:SQL:PSSDIAGXML | WriteTo-StdOut 
                }
                
                # Now set $debug
                if ($true.ToString() -eq $DebugAndTraceConfiguration.DebugEnabled) 
                {
                    # Enable $debug switch.  
                    $script:debug = [bool]$true
                    
                }
                elseif ($false.ToString() -eq $DebugAndTraceConfiguration.DebugEnabled)
                {
                    # Disable $debug switch.  
                    $script:debug = [bool]$false
                }
                else
                {
                    "[Load-DebugAndTraceFlagSettings] : [ERROR] Null or invalid $debug configuration: [{0}] found in debug configuration file: [{1}]" -f $DebugAndTraceConfiguration.DebugEnabled, $gobal:SQL:PSSDIAGXML | WriteTo-StdOut 
                }
            
            } # if ($null -ne $DebugAndTraceConfiguration)
            else
            {
               "[Load-DebugAndTraceFlagSettings] : [ERROR] No debug settings were found in configuration file: [{0}]" -f $gobal:SQL:PSSDIAGXML | WriteTo-StdOut 
            }
        
        } # if ($null -ne $xml)
        else
        {
            "[Load-DebugAndTraceFlagSettings] : [ERROR] Get-Content failed to hydrate configuration from: [{0}]" -f $gobal:SQL:PSSDIAGXML | WriteTo-StdOut
        }
        
    }
    
} # function Load-DebugAndTraceFlagSettings

function Load-FilePolicyConifguration()
{

    trap
    {
        '[Load-FilePolicyConifguration] : [ERROR] Trapped exception ...'
        Report-Error
    }
    
    $ConfigFileFullPath = Join-Path -Path $PWD -ChildPath $global:SQL:PSSDIAGXML
        
    # Read file policy configuration settings in off of the PSSDIAG.XML file
    if ($true -eq (Test-Path -Path $ConfigFileFullPath -PathType Leaf))
    {
        $xml=[xml](Get-Content -Path $ConfigFileFullPath)
        
        if ($null -ne $xml)
        {
            $FileCopyPolicies=@()
            # Load the FilePolicyConfigurations. Force an array in the event that only one policy is returned. Otherwise, I think foreach breaks
            $FileCopyPolicies=@($xml.dsConfig.Collection.Machines.Machine.MachineCollectors.Policy.FileCopyPolicy)
            
            if (($null -ne $FileCopyPolicies) -and (0 -lt $FileCopyPolicies.Count))
            {
                foreach ($FileCopyPolicy in $FileCopyPolicies)
                {
                    # This can happen if the configuration file has no FileCopyPolicy nodes (because I am forcing an array above)
                    if ($null -ne $FileCopyPolicy)
                    {
                        "[Load-FilePolicyConifguration] : [INFO] Instantiating file policy: [{0}]" -f $FileCopyPolicy.Name | WriteTo-StdOut
                        
                        switch ($FileCopyPolicy.Name)
                        {
                            'FilePolicySqlMiniDump' { $global:SQL:FILE_POLICY_SQL_SERVER_MINIDUMPS = Initialize-FilePolicyConfiguration -Policy $FileCopyPolicy }
                            'FilePolicySqlErrorlog' { $global:SQL:FILE_POLICY_SQL_SERVER_ERRORLOGS = Initialize-FilePolicyConfiguration -Policy $FileCopyPolicy }
                            'FilePolicySqlAlwaysOnXeLogs' { $global:SQL:FILE_POLICY_SQL_SERVER_ALWAYSON_XELOGS = Initialize-FilePolicyConfiguration -Policy $FileCopyPolicy }
                            'FilePolicySqlSystemHealthXeLogs' { $global:SQL:FILE_POLICY_SQL_SERVER_SYSTEM_HEALTH_XELOGS  = Initialize-FilePolicyConfiguration -Policy $FileCopyPolicy }
                            'FilePolicySqlFailoverClusterXeLogs' { $global:SQL:FILE_POLICY_SQL_SERVER_FAILOVER_CLUSTER_XELOGS = Initialize-FilePolicyConfiguration -Policy $FileCopyPolicy }
                            'FilePolicyDefault'               { $global:SQL:FILE_POLICY_SQL_SERVER_DEFAULT = Initialize-FilePolicyConfiguration -Policy $FileCopyPolicy }
							'FilePolicyConfigurationFile' { $global:SQL:FILE_POLICY_CONFIGURATION_FILE = Initialize-FilePolicyConfiguration -Policy $FileCopyPolicy }                            
                            default { "[Load-FilePolicyConifguration] : [ERROR] Unexpected file policy type: [{0}] found in configration file. Policy ignored." -f $FileCopyPolicy.Name | WriteTo-StdOut }
                        }
                    }
                }
                
            } # (($null -ne $FileCopyPolicies) -and (0 -lt $FileCopyPolicies.Count))
            else
            {
               '[Load-FilePolicyConifguration] : [ERROR] Failed to extract file policy configuration from hydrated configuration' | WriteTo-StdOut
            }
       
        } # if ($null -ne $xml)
        else
        {
            "[Load-FilePolicyConifguration] : [ERROR] Get-Content failed to hydrate configuration from: [{0}]" -f $gobal:SQL:PSSDIAGXML | WriteTo-StdOut
        }
    }
    else
    {
        '[Load-FilePolicyConifguration] : [ERROR] The PSSDIAG.XML configuration file was not found in it''s expected location [{0}]' -f $PWD | WriteTo-StdOut
        Report-Error
    }

}
# Function : Initialize-DsdEnvironment
# ------------------------------------
#
# PowerShell Version:
#			Written to be compatible with PowerShell 1.0
#
# Visibility:
#			Public : Call this function from your PowerShell script
#
# Description:
#			This function will load the SQL Server PowerShell snapins into your PowerShell session if they aren't already loaded
#
#			Also sets the PowerShell ErrorActionPreference to "Continue"
#
#			This function is called automatically when utils_DSD (this file) is "dot sourced" into your TS_Main
# 
# Arguments:
#			None
#
# Returns:
#			Nothing ...
# Owner:
#			DanSha
#
# Revision History: 
#			1.0 08/??/2011		DanSha
#				Original Version
#			1.1 11/23/2011		DanSha
#				Fix errant error message indicating PS snapins were not installed that was issued if the 
#				function was run more than once in same PS session. 
#           1.2 01/18/2012      DanSha
#                Replace double quoted strings with single quoted strings when variable expansion is not desires
#
function Initialize-DsdEnvironment ()
{
	trap 
    {
		'[Initialize-DsdEnvironment] : [ERROR] Trapped exception ...' | WriteTo-Stdout
		Report-Error
    }
	 
	# Load the SQL Snapins if not already loaded
	#
	if ( ($true -eq (Check-SqlSnapinsAreInstalled)) -and ($false -eq (Check-SqlSnapinsAreLoaded)) ) 
	{
		Load-SqlSnapins
	} elseif ((Check-SqlSnapinsAreInstalled) -eq $false) {
		WriteTo-StdOut '[Initialize-DsdEnvironment] : Sql Server PowerShell Snapins are not installed'
	}

    #Load Debug and trace flag settings. Do this first as Load-FilePolicyConfiguration has a debug spew
    Load-DebugAndTraceFlagSettings
    
	#Load File Policy Configurations
	Load-FilePolicyConifguration

}

# Have to write some additional helper functions to go find SSAS instance root key before I can improve what's reported here
function Check-IsSsasDiskResourceOnline ([string]$PathToTest)
{
    $Error.Clear()           
    trap 
    {
    	"[Check-IsSsasDiskResourceOnline] : Trapped exception ..." | WriteTo-StdOut
    	Report-Error
    }
    
	[string]$Drive=$null
	[bool]$DiskOnline=$false
	
    if (($null -ne $PathToTest) -and ([string]::Empty -ne $PathToTest))
    {
        $Drive = ($PathToTest.Split("\"))[0]
		
        if (Test-Path $Drive)
        {
            # Disk online
			Write-Host " ##### Disk ONLINE "
            $DiskOnline = $true
            
        } # if (Test-Path $Drive)
        else  
        {
			Write-Host " ##### Disk OFFLINE "
            # If FindSqlDiskResource returns false the disk is an offline cluster resource or an invalid drive letter
        	#
       		if (($DiskOnline = FindSQLDiskResource($Drive)) -eq $false)
        	{
       		   "[Check-IsSsasDiskResourceOnline] : Invalid Path [{0}]. Drive: [{1}] is invalid of offline from this node at this time" -f $PathToTest, $Drive | WriteTo-StdOut
        	}
        } 
       
    } # if ($null -ne $PathToTest)
    else
    {
        '[Check-IsSsasDiskResourceOnline] : [ERROR] Required parameter -PathToTest was not specified' | WriteTo-StdOut
    }
    
    return $DiskOnline
}

Initialize-DsdEnvironment


# SIG # Begin signature block
# MIInmAYJKoZIhvcNAQcCoIIniTCCJ4UCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCCjR3z1OsSCrTcl
# shQ+QObff6fvsPEB34HGNirIvXmgOaCCDXYwggX0MIID3KADAgECAhMzAAACy7d1
# OfsCcUI2AAAAAALLMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNVBAYTAlVTMRMwEQYD
# VQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNy
# b3NvZnQgQ29ycG9yYXRpb24xKDAmBgNVBAMTH01pY3Jvc29mdCBDb2RlIFNpZ25p
# bmcgUENBIDIwMTEwHhcNMjIwNTEyMjA0NTU5WhcNMjMwNTExMjA0NTU5WjB0MQsw
# CQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9u
# ZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMR4wHAYDVQQDExVNaWNy
# b3NvZnQgQ29ycG9yYXRpb24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
# AQC3sN0WcdGpGXPZIb5iNfFB0xZ8rnJvYnxD6Uf2BHXglpbTEfoe+mO//oLWkRxA
# wppditsSVOD0oglKbtnh9Wp2DARLcxbGaW4YanOWSB1LyLRpHnnQ5POlh2U5trg4
# 3gQjvlNZlQB3lL+zrPtbNvMA7E0Wkmo+Z6YFnsf7aek+KGzaGboAeFO4uKZjQXY5
# RmMzE70Bwaz7hvA05jDURdRKH0i/1yK96TDuP7JyRFLOvA3UXNWz00R9w7ppMDcN
# lXtrmbPigv3xE9FfpfmJRtiOZQKd73K72Wujmj6/Su3+DBTpOq7NgdntW2lJfX3X
# a6oe4F9Pk9xRhkwHsk7Ju9E/AgMBAAGjggFzMIIBbzAfBgNVHSUEGDAWBgorBgEE
# AYI3TAgBBggrBgEFBQcDAzAdBgNVHQ4EFgQUrg/nt/gj+BBLd1jZWYhok7v5/w4w
# RQYDVR0RBD4wPKQ6MDgxHjAcBgNVBAsTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEW
# MBQGA1UEBRMNMjMwMDEyKzQ3MDUyODAfBgNVHSMEGDAWgBRIbmTlUAXTgqoXNzci
# tW2oynUClTBUBgNVHR8ETTBLMEmgR6BFhkNodHRwOi8vd3d3Lm1pY3Jvc29mdC5j
# b20vcGtpb3BzL2NybC9NaWNDb2RTaWdQQ0EyMDExXzIwMTEtMDctMDguY3JsMGEG
# CCsGAQUFBwEBBFUwUzBRBggrBgEFBQcwAoZFaHR0cDovL3d3dy5taWNyb3NvZnQu
# Y29tL3BraW9wcy9jZXJ0cy9NaWNDb2RTaWdQQ0EyMDExXzIwMTEtMDctMDguY3J0
# MAwGA1UdEwEB/wQCMAAwDQYJKoZIhvcNAQELBQADggIBAJL5t6pVjIRlQ8j4dAFJ
# ZnMke3rRHeQDOPFxswM47HRvgQa2E1jea2aYiMk1WmdqWnYw1bal4IzRlSVf4czf
# zx2vjOIOiaGllW2ByHkfKApngOzJmAQ8F15xSHPRvNMmvpC3PFLvKMf3y5SyPJxh
# 922TTq0q5epJv1SgZDWlUlHL/Ex1nX8kzBRhHvc6D6F5la+oAO4A3o/ZC05OOgm4
# EJxZP9MqUi5iid2dw4Jg/HvtDpCcLj1GLIhCDaebKegajCJlMhhxnDXrGFLJfX8j
# 7k7LUvrZDsQniJZ3D66K+3SZTLhvwK7dMGVFuUUJUfDifrlCTjKG9mxsPDllfyck
# 4zGnRZv8Jw9RgE1zAghnU14L0vVUNOzi/4bE7wIsiRyIcCcVoXRneBA3n/frLXvd
# jDsbb2lpGu78+s1zbO5N0bhHWq4j5WMutrspBxEhqG2PSBjC5Ypi+jhtfu3+x76N
# mBvsyKuxx9+Hm/ALnlzKxr4KyMR3/z4IRMzA1QyppNk65Ui+jB14g+w4vole33M1
# pVqVckrmSebUkmjnCshCiH12IFgHZF7gRwE4YZrJ7QjxZeoZqHaKsQLRMp653beB
# fHfeva9zJPhBSdVcCW7x9q0c2HVPLJHX9YCUU714I+qtLpDGrdbZxD9mikPqL/To
# /1lDZ0ch8FtePhME7houuoPcMIIHejCCBWKgAwIBAgIKYQ6Q0gAAAAAAAzANBgkq
# hkiG9w0BAQsFADCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24x
# EDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlv
# bjEyMDAGA1UEAxMpTWljcm9zb2Z0IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5
# IDIwMTEwHhcNMTEwNzA4MjA1OTA5WhcNMjYwNzA4MjEwOTA5WjB+MQswCQYDVQQG
# EwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwG
# A1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSgwJgYDVQQDEx9NaWNyb3NvZnQg
# Q29kZSBTaWduaW5nIFBDQSAyMDExMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC
# CgKCAgEAq/D6chAcLq3YbqqCEE00uvK2WCGfQhsqa+laUKq4BjgaBEm6f8MMHt03
# a8YS2AvwOMKZBrDIOdUBFDFC04kNeWSHfpRgJGyvnkmc6Whe0t+bU7IKLMOv2akr
# rnoJr9eWWcpgGgXpZnboMlImEi/nqwhQz7NEt13YxC4Ddato88tt8zpcoRb0Rrrg
# OGSsbmQ1eKagYw8t00CT+OPeBw3VXHmlSSnnDb6gE3e+lD3v++MrWhAfTVYoonpy
# 4BI6t0le2O3tQ5GD2Xuye4Yb2T6xjF3oiU+EGvKhL1nkkDstrjNYxbc+/jLTswM9
# sbKvkjh+0p2ALPVOVpEhNSXDOW5kf1O6nA+tGSOEy/S6A4aN91/w0FK/jJSHvMAh
# dCVfGCi2zCcoOCWYOUo2z3yxkq4cI6epZuxhH2rhKEmdX4jiJV3TIUs+UsS1Vz8k
# A/DRelsv1SPjcF0PUUZ3s/gA4bysAoJf28AVs70b1FVL5zmhD+kjSbwYuER8ReTB
# w3J64HLnJN+/RpnF78IcV9uDjexNSTCnq47f7Fufr/zdsGbiwZeBe+3W7UvnSSmn
# Eyimp31ngOaKYnhfsi+E11ecXL93KCjx7W3DKI8sj0A3T8HhhUSJxAlMxdSlQy90
# lfdu+HggWCwTXWCVmj5PM4TasIgX3p5O9JawvEagbJjS4NaIjAsCAwEAAaOCAe0w
# ggHpMBAGCSsGAQQBgjcVAQQDAgEAMB0GA1UdDgQWBBRIbmTlUAXTgqoXNzcitW2o
# ynUClTAZBgkrBgEEAYI3FAIEDB4KAFMAdQBiAEMAQTALBgNVHQ8EBAMCAYYwDwYD
# VR0TAQH/BAUwAwEB/zAfBgNVHSMEGDAWgBRyLToCMZBDuRQFTuHqp8cx0SOJNDBa
# BgNVHR8EUzBRME+gTaBLhklodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL2Ny
# bC9wcm9kdWN0cy9NaWNSb29DZXJBdXQyMDExXzIwMTFfMDNfMjIuY3JsMF4GCCsG
# AQUFBwEBBFIwUDBOBggrBgEFBQcwAoZCaHR0cDovL3d3dy5taWNyb3NvZnQuY29t
# L3BraS9jZXJ0cy9NaWNSb29DZXJBdXQyMDExXzIwMTFfMDNfMjIuY3J0MIGfBgNV
# HSAEgZcwgZQwgZEGCSsGAQQBgjcuAzCBgzA/BggrBgEFBQcCARYzaHR0cDovL3d3
# dy5taWNyb3NvZnQuY29tL3BraW9wcy9kb2NzL3ByaW1hcnljcHMuaHRtMEAGCCsG
# AQUFBwICMDQeMiAdAEwAZQBnAGEAbABfAHAAbwBsAGkAYwB5AF8AcwB0AGEAdABl
# AG0AZQBuAHQALiAdMA0GCSqGSIb3DQEBCwUAA4ICAQBn8oalmOBUeRou09h0ZyKb
# C5YR4WOSmUKWfdJ5DJDBZV8uLD74w3LRbYP+vj/oCso7v0epo/Np22O/IjWll11l
# hJB9i0ZQVdgMknzSGksc8zxCi1LQsP1r4z4HLimb5j0bpdS1HXeUOeLpZMlEPXh6
# I/MTfaaQdION9MsmAkYqwooQu6SpBQyb7Wj6aC6VoCo/KmtYSWMfCWluWpiW5IP0
# wI/zRive/DvQvTXvbiWu5a8n7dDd8w6vmSiXmE0OPQvyCInWH8MyGOLwxS3OW560
# STkKxgrCxq2u5bLZ2xWIUUVYODJxJxp/sfQn+N4sOiBpmLJZiWhub6e3dMNABQam
# ASooPoI/E01mC8CzTfXhj38cbxV9Rad25UAqZaPDXVJihsMdYzaXht/a8/jyFqGa
# J+HNpZfQ7l1jQeNbB5yHPgZ3BtEGsXUfFL5hYbXw3MYbBL7fQccOKO7eZS/sl/ah
# XJbYANahRr1Z85elCUtIEJmAH9AAKcWxm6U/RXceNcbSoqKfenoi+kiVH6v7RyOA
# 9Z74v2u3S5fi63V4GuzqN5l5GEv/1rMjaHXmr/r8i+sLgOppO6/8MO0ETI7f33Vt
# Y5E90Z1WTk+/gFcioXgRMiF670EKsT/7qMykXcGhiJtXcVZOSEXAQsmbdlsKgEhr
# /Xmfwb1tbWrJUnMTDXpQzTGCGXgwghl0AgEBMIGVMH4xCzAJBgNVBAYTAlVTMRMw
# EQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVN
# aWNyb3NvZnQgQ29ycG9yYXRpb24xKDAmBgNVBAMTH01pY3Jvc29mdCBDb2RlIFNp
# Z25pbmcgUENBIDIwMTECEzMAAALLt3U5+wJxQjYAAAAAAsswDQYJYIZIAWUDBAIB
# BQCggbAwGQYJKoZIhvcNAQkDMQwGCisGAQQBgjcCAQQwHAYKKwYBBAGCNwIBCzEO
# MAwGCisGAQQBgjcCARUwLwYJKoZIhvcNAQkEMSIEIHcMsQQMEIdjrSHFqLsfKC1U
# BoDu3nImD6vTM46ynxw6MEQGCisGAQQBgjcCAQwxNjA0oBSAEgBNAGkAYwByAG8A
# cwBvAGYAdKEcgBpodHRwczovL3d3dy5taWNyb3NvZnQuY29tIDANBgkqhkiG9w0B
# AQEFAASCAQBNbOJj+k9yQpBAevkV9dfh9PNHsOaHsaFBU6nI5u6NivCSWUhFgkRt
# HGgFS+AhAcwsdG5WtUe2OJXBvSLtoekRzyb7kGEpkK3pqF6jG0SpClcsaeV6lxJz
# AwAsAsmN8FEhZ5vRuSSk4WrQJVQLBlFIKWV80GSD1jA4FE/rlsHutOGfKcWQrmN3
# RdiJy2h9/RjeHX8OA/bSO0yklLXbcIWrQ1pnV1vq4zv6FO06EchvXlpuGk/Xj3Mh
# P9F70gvE4/xyB6JXJV3WTrciJcm0Bfl6c2jrRaOydLamN6IsYoYOczGz0O49p71P
# XGEvkIsVD7ipJW4a6HlMs0NcqKGYw5dPoYIXADCCFvwGCisGAQQBgjcDAwExghbs
# MIIW6AYJKoZIhvcNAQcCoIIW2TCCFtUCAQMxDzANBglghkgBZQMEAgEFADCCAVEG
# CyqGSIb3DQEJEAEEoIIBQASCATwwggE4AgEBBgorBgEEAYRZCgMBMDEwDQYJYIZI
# AWUDBAIBBQAEIE+oDIDsxpgzFR8K36ShQh7SimBB90vjTF5aT5Vr0kANAgZi1XtC
# d1YYEzIwMjIwODAxMDgxNTExLjg1N1owBIACAfSggdCkgc0wgcoxCzAJBgNVBAYT
# AlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYD
# VQQKExVNaWNyb3NvZnQgQ29ycG9yYXRpb24xJTAjBgNVBAsTHE1pY3Jvc29mdCBB
# bWVyaWNhIE9wZXJhdGlvbnMxJjAkBgNVBAsTHVRoYWxlcyBUU1MgRVNOOjEyQkMt
# RTNBRS03NEVCMSUwIwYDVQQDExxNaWNyb3NvZnQgVGltZS1TdGFtcCBTZXJ2aWNl
# oIIRVzCCBwwwggT0oAMCAQICEzMAAAGhAYVVmblUXYoAAQAAAaEwDQYJKoZIhvcN
# AQELBQAwfDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNV
# BAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEmMCQG
# A1UEAxMdTWljcm9zb2Z0IFRpbWUtU3RhbXAgUENBIDIwMTAwHhcNMjExMjAyMTkw
# NTI0WhcNMjMwMjI4MTkwNTI0WjCByjELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldh
# c2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBD
# b3Jwb3JhdGlvbjElMCMGA1UECxMcTWljcm9zb2Z0IEFtZXJpY2EgT3BlcmF0aW9u
# czEmMCQGA1UECxMdVGhhbGVzIFRTUyBFU046MTJCQy1FM0FFLTc0RUIxJTAjBgNV
# BAMTHE1pY3Jvc29mdCBUaW1lLVN0YW1wIFNlcnZpY2UwggIiMA0GCSqGSIb3DQEB
# AQUAA4ICDwAwggIKAoICAQDayTxe5WukkrYxxVuHLYW9BEWCD9kkjnnHsOKwGddI
# PbZlLY+l5ovLDNf+BEMQKAZQI3DX91l1yCDuP9X7tOPC48ZRGXA/bf9ql0FK5438
# gIl7cV528XeEOFwc/A+UbIUfW296Omg8Z62xaQv3jrG4U/priArF/er1UA1HNuIG
# UyqjlygiSPwK2NnFApi1JD+Uef5c47kh7pW1Kj7RnchpFeY9MekPQRia7cEaUYU4
# sqCiJVdDJpefLvPT9EdthlQx75ldx+AwZf2a9T7uQRSBh8tpxPdIDDkKiWMwjKTr
# AY09A3I/jidqPuc8PvX+sqxqyZEN2h4GA0Edjmk64nkIukAK18K5nALDLO9SMTxp
# AwQIHRDtZeTClvAPCEoy1vtPD7f+eqHqStuu+XCkfRjXEpX9+h9frsB0/BgD5CBf
# 3ELLAa8TefMfHZWEJRTPNrbXMKizSrUSkVv/3HP/ZsJpwaz5My2Rbyc3Ah9bT76e
# BJkyfT5FN9v/KQ0HnxhRMs6HHhTmNx+LztYci+vHf0D3QH1eCjZWZRjp1mOyxpPU
# 2mDMG6gelvJse1JzRADo7YIok/J3Ccbm8MbBbm85iogFltFHecHFEFwrsDGBFnNY
# HMhcbarQNA+gY2e2l9fAkX3MjI7Uklkoz74/P6KIqe5jcd9FPCbbSbYH9OLsteeY
# OQIDAQABo4IBNjCCATIwHQYDVR0OBBYEFBa/IDLbY475VQyKiZSw47l0/cypMB8G
# A1UdIwQYMBaAFJ+nFV0AXmJdg/Tl0mWnG1M1GelyMF8GA1UdHwRYMFYwVKBSoFCG
# Tmh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2lvcHMvY3JsL01pY3Jvc29mdCUy
# MFRpbWUtU3RhbXAlMjBQQ0ElMjAyMDEwKDEpLmNybDBsBggrBgEFBQcBAQRgMF4w
# XAYIKwYBBQUHMAKGUGh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2lvcHMvY2Vy
# dHMvTWljcm9zb2Z0JTIwVGltZS1TdGFtcCUyMFBDQSUyMDIwMTAoMSkuY3J0MAwG
# A1UdEwEB/wQCMAAwEwYDVR0lBAwwCgYIKwYBBQUHAwgwDQYJKoZIhvcNAQELBQAD
# ggIBACDDIxElfXlG5YKcKrLPSS+f3JWZprwKEiASvivaHTBRlXtAs+TkadcsEei+
# 9w5vmF5tCUzTH4c0nCI7bZxnsL+S6XsiOs3Z1V4WX+IwoXUJ4zLvs0+mT4vjGDtY
# fKQ/bsmJKar2c99m/fHv1Wm2CTcyaePvi86Jh3UyLjdRILWbtzs4oImFMwwKbzHd
# PopxrBhgi+C1YZshosWLlgzyuxjUl+qNg1m52MJmf11loI7D9HJoaQzd+rf928Y8
# rvULmg2h/G50o+D0UJ1Fa/cJJaHfB3sfKw9X6GrtXYGjmM3+g+AhaVsfupKXNtOF
# u5tnLKvAH5OIjEDYV1YKmlXuBuhbYassygPFMmNgG2Ank3drEcDcZhCXXqpRszNo
# 1F6Gu5JCpQZXbOJM9Ue5PlJKtmImAYIGsw+pnHy/r5ggSYOp4g5Z1oU9GhVCM3V0
# T9adee6OUXBk1rE4dZc/UsPlj0qoiljL+lN1A5gkmmz7k5tIObVGB7dJdz8J0FwX
# RE5qYu1AdvauVbZwGQkL1x8aK/svjEQW0NUyJ29znDHiXl5vLoRTjjFpshUBi2+I
# Y+mNqbLmj24j5eT+bjDlE3HmNtLPpLcMDYqZ1H+6U6YmaiNmac2jRXDAaeEE/uoD
# Mt2dArfJP7M+MDv3zzNNTINeuNEtDVgm9zwfgIUCXnDZuVtiMIIHcTCCBVmgAwIB
# AgITMwAAABXF52ueAptJmQAAAAAAFTANBgkqhkiG9w0BAQsFADCBiDELMAkGA1UE
# BhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAc
# BgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEyMDAGA1UEAxMpTWljcm9zb2Z0
# IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTAwHhcNMjEwOTMwMTgyMjI1
# WhcNMzAwOTMwMTgzMjI1WjB8MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGlu
# Z3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBv
# cmF0aW9uMSYwJAYDVQQDEx1NaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMDCC
# AiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAOThpkzntHIhC3miy9ckeb0O
# 1YLT/e6cBwfSqWxOdcjKNVf2AX9sSuDivbk+F2Az/1xPx2b3lVNxWuJ+Slr+uDZn
# hUYjDLWNE893MsAQGOhgfWpSg0S3po5GawcU88V29YZQ3MFEyHFcUTE3oAo4bo3t
# 1w/YJlN8OWECesSq/XJprx2rrPY2vjUmZNqYO7oaezOtgFt+jBAcnVL+tuhiJdxq
# D89d9P6OU8/W7IVWTe/dvI2k45GPsjksUZzpcGkNyjYtcI4xyDUoveO0hyTD4MmP
# frVUj9z6BVWYbWg7mka97aSueik3rMvrg0XnRm7KMtXAhjBcTyziYrLNueKNiOSW
# rAFKu75xqRdbZ2De+JKRHh09/SDPc31BmkZ1zcRfNN0Sidb9pSB9fvzZnkXftnIv
# 231fgLrbqn427DZM9ituqBJR6L8FA6PRc6ZNN3SUHDSCD/AQ8rdHGO2n6Jl8P0zb
# r17C89XYcz1DTsEzOUyOArxCaC4Q6oRRRuLRvWoYWmEBc8pnol7XKHYC4jMYcten
# IPDC+hIK12NvDMk2ZItboKaDIV1fMHSRlJTYuVD5C4lh8zYGNRiER9vcG9H9stQc
# xWv2XFJRXRLbJbqvUAV6bMURHXLvjflSxIUXk8A8FdsaN8cIFRg/eKtFtvUeh17a
# j54WcmnGrnu3tz5q4i6tAgMBAAGjggHdMIIB2TASBgkrBgEEAYI3FQEEBQIDAQAB
# MCMGCSsGAQQBgjcVAgQWBBQqp1L+ZMSavoKRPEY1Kc8Q/y8E7jAdBgNVHQ4EFgQU
# n6cVXQBeYl2D9OXSZacbUzUZ6XIwXAYDVR0gBFUwUzBRBgwrBgEEAYI3TIN9AQEw
# QTA/BggrBgEFBQcCARYzaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3BraW9wcy9E
# b2NzL1JlcG9zaXRvcnkuaHRtMBMGA1UdJQQMMAoGCCsGAQUFBwMIMBkGCSsGAQQB
# gjcUAgQMHgoAUwB1AGIAQwBBMAsGA1UdDwQEAwIBhjAPBgNVHRMBAf8EBTADAQH/
# MB8GA1UdIwQYMBaAFNX2VsuP6KJcYmjRPZSQW9fOmhjEMFYGA1UdHwRPME0wS6BJ
# oEeGRWh0dHA6Ly9jcmwubWljcm9zb2Z0LmNvbS9wa2kvY3JsL3Byb2R1Y3RzL01p
# Y1Jvb0NlckF1dF8yMDEwLTA2LTIzLmNybDBaBggrBgEFBQcBAQROMEwwSgYIKwYB
# BQUHMAKGPmh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2kvY2VydHMvTWljUm9v
# Q2VyQXV0XzIwMTAtMDYtMjMuY3J0MA0GCSqGSIb3DQEBCwUAA4ICAQCdVX38Kq3h
# LB9nATEkW+Geckv8qW/qXBS2Pk5HZHixBpOXPTEztTnXwnE2P9pkbHzQdTltuw8x
# 5MKP+2zRoZQYIu7pZmc6U03dmLq2HnjYNi6cqYJWAAOwBb6J6Gngugnue99qb74p
# y27YP0h1AdkY3m2CDPVtI1TkeFN1JFe53Z/zjj3G82jfZfakVqr3lbYoVSfQJL1A
# oL8ZthISEV09J+BAljis9/kpicO8F7BUhUKz/AyeixmJ5/ALaoHCgRlCGVJ1ijbC
# HcNhcy4sa3tuPywJeBTpkbKpW99Jo3QMvOyRgNI95ko+ZjtPu4b6MhrZlvSP9pEB
# 9s7GdP32THJvEKt1MMU0sHrYUP4KWN1APMdUbZ1jdEgssU5HLcEUBHG/ZPkkvnNt
# yo4JvbMBV0lUZNlz138eW0QBjloZkWsNn6Qo3GcZKCS6OEuabvshVGtqRRFHqfG3
# rsjoiV5PndLQTHa1V1QJsWkBRH58oWFsc/4Ku+xBZj1p/cvBQUl+fpO+y/g75LcV
# v7TOPqUxUYS8vwLBgqJ7Fx0ViY1w/ue10CgaiQuPNtq6TPmb/wrpNPgkNWcr4A24
# 5oyZ1uEi6vAnQj0llOZ0dFtq0Z4+7X6gMTN9vMvpe784cETRkPHIqzqKOghif9lw
# Y1NNje6CbaUFEMFxBmoQtB1VM1izoXBm8qGCAs4wggI3AgEBMIH4oYHQpIHNMIHK
# MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVk
# bW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSUwIwYDVQQLExxN
# aWNyb3NvZnQgQW1lcmljYSBPcGVyYXRpb25zMSYwJAYDVQQLEx1UaGFsZXMgVFNT
# IEVTTjoxMkJDLUUzQUUtNzRFQjElMCMGA1UEAxMcTWljcm9zb2Z0IFRpbWUtU3Rh
# bXAgU2VydmljZaIjCgEBMAcGBSsOAwIaAxUAG3F2jO4LEMVLwgKGXdYMN4FBgOCg
# gYMwgYCkfjB8MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4G
# A1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSYw
# JAYDVQQDEx1NaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMDANBgkqhkiG9w0B
# AQUFAAIFAOaRxQEwIhgPMjAyMjA4MDExMTIwMzNaGA8yMDIyMDgwMjExMjAzM1ow
# dzA9BgorBgEEAYRZCgQBMS8wLTAKAgUA5pHFAQIBADAKAgEAAgIe+QIB/zAHAgEA
# AgIRzDAKAgUA5pMWgQIBADA2BgorBgEEAYRZCgQCMSgwJjAMBgorBgEEAYRZCgMC
# oAowCAIBAAIDB6EgoQowCAIBAAIDAYagMA0GCSqGSIb3DQEBBQUAA4GBAMdg/2Ic
# 2gdRxdHFUFdJMeqK2GQ4eeJe4KU3uJFZSWtDNMsYdgfRBioQewI0jA36Q7n93U2H
# 2EUIMKie+yy3JZGEC3R7RNFvadse/lYTH9idktnd6B/nLTFPzKKzNxNL/s0kYKbs
# IFS75Zhce8rvKa256KzxAwgDOFvKbA/CLFftMYIEDTCCBAkCAQEwgZMwfDELMAkG
# A1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQx
# HjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWljcm9z
# b2Z0IFRpbWUtU3RhbXAgUENBIDIwMTACEzMAAAGhAYVVmblUXYoAAQAAAaEwDQYJ
# YIZIAWUDBAIBBQCgggFKMBoGCSqGSIb3DQEJAzENBgsqhkiG9w0BCRABBDAvBgkq
# hkiG9w0BCQQxIgQg6bvKbEQ3aJlhYB//zxhrT6Tp89TnE7pUQHDCpQNl0LAwgfoG
# CyqGSIb3DQEJEAIvMYHqMIHnMIHkMIG9BCDrCFTxOoGCaCCCjoRyBe1JSQrMJeCC
# TyErziiJ347QhDCBmDCBgKR+MHwxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpXYXNo
# aW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29y
# cG9yYXRpb24xJjAkBgNVBAMTHU1pY3Jvc29mdCBUaW1lLVN0YW1wIFBDQSAyMDEw
# AhMzAAABoQGFVZm5VF2KAAEAAAGhMCIEIKLR1CM5CE/xpideFbkazxTnyCfhdw/B
# krS8J+WcwTuEMA0GCSqGSIb3DQEBCwUABIICAEn/N4ECc2yFeISZ5rI8b2Nexutx
# XugWjV+c16dswOQ3fnYdZox9qbcyR7gnKjmtaeUFYtKNfTyMSnDJoMahCNkZF8jt
# cN5SCFqz8AdahqenyKl8l1JIa63wjRvGcEEP7JgDgra9ZOahhNkq48ibBvqneGXG
# 6mrl5bSEl1qYPt08XxjTWSMuCbOV+VPyStzOqqBbyV6tcJeFBQmxRLJyJvwtcrxk
# 77pNSsf58iO89+u2ZuMAtx1Ai7tOMeyI3IXKaKqrFiypSQ05M4h8u5QZTXlSDV/9
# hHu1396PitBeTPQJgDi40+xhCoYM93UyZfYSx05q5NUh4KUtv18E8C9y0eYoe2Nr
# n/1TkGDGDPr0N3thkQr72Wx66XuDcfOpNAoLEdgOVKArfenvc6lBJpD8p7WWp03T
# yCvk5HiiWT5a2aLdRhVydUwYAqL920cGhKgQoVEVtjwrG1tY2Up7ov7TKfCwpPYz
# vm1SXU9nex03lbKcJxCgcD65ZTBI+LLeBD1m5rgtdffxm5JIojIlBKf7IQN2BdfO
# 6QZTAdWZ9mXwob/EN/xDJq2b5lu8zu25DqQeU847GNQA5oXn1TtNzlCPRbksSI/M
# 2gF0hwiVYFsRKYBcOaiTh462SE6G2jeej6/Kw0BwYdrJYYEok5193eN9N+m4r3oN
# JB2OD1QC0hR2GzCU
# SIG # End signature block
